---
permalink: /js/search.js
eleventyExcludeFromCollections: true
---
// Simple client-side search for ScotAccount documentation with Fuse.js fuzzy search
// Fuse.js is loaded globally via CDN and available as window.Fuse

class DocumentationSearch {
  constructor() {
    this.searchData = [];
    this.fuse = null;
    this.searchInput = null;
    this.searchResults = null;
    this.init();
  }

  async init() {
    await this.loadSearchData();
    this.setupFuse();
    this.setupSearchInterface();
    this.bindEvents();
  }

  async loadSearchData() {
    // Build search index from pages with full content
    const pages = [
      {% for page in fullSearchIndex.pages %}
      {
        title: {{ page.title | dump | safe }},
        url: {{ page.url | dump | safe }},
        content: {{ page.content | dump | safe }},
        summary: {{ page.summary | dump | safe }},
        keywords: {{ page.keywords | dump | safe }},
        sections: {{ page.sections | dump | safe }}
      }{% if not loop.last %},{% endif %}
      {% endfor %}
    ];
    this.searchData = pages;
  }

  setupFuse() {
    this.fuse = new window.Fuse(this.searchData, {
      keys: [
        { name: "title", weight: 2 },     // Title matches are more important
        { name: "keywords", weight: 1.5 }, // Keywords are fairly important
        { name: "content", weight: 1 },    // Full content search
        { name: "summary", weight: 0.8 }   // Summary is less important
      ],
      threshold: 0.4,           // Balance between precision and recall
      minMatchCharLength: 2,    // Minimum 2 characters
      includeScore: true,
      ignoreLocation: true,     // Search anywhere in content
      findAllMatches: true,     // Find all matches in content
      shouldSort: true          // Sort results by score
    });
  }

  setupSearchInterface() {
    // Get search input from header
    this.searchInput = document.getElementById("search-input");

    // Create search results container
    if (!document.getElementById("search-results")) {
      const resultsContainer = document.createElement("div");
      resultsContainer.id = "search-results";
      resultsContainer.className = "search-results";
      resultsContainer.style.display = "none";

      // Insert after search form
      const searchForm = document.querySelector(".sg-header__search-form");
      if (searchForm) {
        searchForm.parentNode.insertBefore(
          resultsContainer,
          searchForm.nextSibling
        );
      }
    }
    this.searchResults = document.getElementById("search-results");
  }

  bindEvents() {
    if (!this.searchInput) return;

    // Search on input
    this.searchInput.addEventListener("input", (e) => {
      const query = e.target.value.trim();
      if (query.length >= 2) {
        this.performSearch(query);
      } else {
        this.hideResults();
      }
    });

    // Handle search form submission
    const searchForm = document.querySelector(".sg-header__search-form");
    if (searchForm) {
      searchForm.addEventListener("submit", (e) => {
        e.preventDefault();
        const query = this.searchInput.value.trim();
        if (query.length >= 2) {
          this.performSearch(query);
        }
      });
    }

    // Hide results when clicking outside
    document.addEventListener("click", (e) => {
      if (
        !e.target.closest(".sg-header__search") &&
        !e.target.closest(".search-results")
      ) {
        this.hideResults();
      }
    });

    // Keyboard navigation
    this.searchInput.addEventListener("keydown", (e) => {
      if (e.key === "Escape") {
        this.hideResults();
        this.searchInput.blur();
      }
    });
  }

  performSearch(query, renderToPage = false) {
    if (!this.fuse) return;
    
    const results = this.fuse.search(query);
    const items = results.map((r) => r.item);
    
    if (renderToPage && document.getElementById("search-results-page")) {
      this.displayResultsPage(items, query);
    } else {
      this.displayResults(items, query);
    }
  }

  findBestSection(result, query) {
    if (!result.sections || result.sections.length === 0) {
      return null;
    }
    
    const queryLower = query.toLowerCase();
    let bestSection = null;
    let bestScore = -1;
    
    // Find the section with the best match
    result.sections.forEach(section => {
      const sectionContent = section.content.toLowerCase();
      const headingContent = section.heading.toLowerCase();
      
      // Higher score if query matches in heading
      if (headingContent.includes(queryLower)) {
        const score = 10;
        if (score > bestScore) {
          bestScore = score;
          bestSection = section;
        }
      }
      // Lower score if query matches in content
      else if (sectionContent.includes(queryLower)) {
        const score = 5;
        if (score > bestScore) {
          bestScore = score;
          bestSection = section;
        }
      }
    });
    
    return bestSection;
  }

  displayResults(results, query) {
    if (!this.searchResults) return;

    if (results.length === 0) {
      this.searchResults.innerHTML = `
        <div class="search-results__container">
          <div class="search-results__empty">
            <p>No results found for "${query}"</p>
            <p class="search-results__suggestion">Try searching for: authentication, token, OIDC, setup, or architecture</p>
          </div>
        </div>
      `;
    } else {
      const resultsHTML = results
        .map(
          (result) => {
            // Find the best matching section for deep linking
            const bestSection = this.findBestSection(result, query);
            const targetUrl = bestSection ? 
              `${result.url}#${bestSection.id}` : 
              result.url;
            const sectionInfo = bestSection ? 
              ` <span class="search-results__section">→ ${bestSection.heading}</span>` : 
              '';
            
            return `
        <div class="search-results__item">
          <a href="${targetUrl}" class="search-results__link">
            <h3 class="search-results__title">${result.title}${sectionInfo}</h3>
            <p class="search-results__summary">${this.getSearchSummary(
              result,
              query,
              bestSection
            )}</p>
          </a>
        </div>
      `;
          }
        )
        .join("");

      this.searchResults.innerHTML = `
        <div class="search-results__container">
          <div class="search-results__header">
            <p class="search-results__count">${results.length} result${
        results.length !== 1 ? "s" : ""
      } for "${query}"</p>
          </div>
          ${resultsHTML}
        </div>
      `;
    }

    this.searchResults.style.display = "block";
  }

  displayResultsPage(results, query) {
    const container = document.getElementById("search-results-page");
    if (!container) return;
    if (results.length === 0) {
      container.innerHTML = `
        <div class="search-results__container">
          <div class="search-results__empty">
            <p>No results found for "${query}"</p>
            <p class="search-results__suggestion">Try searching for: authentication, token, OIDC, setup, or architecture</p>
          </div>
        </div>
      `;
    } else {
      const resultsHTML = results
        .map(
          (result) => {
            // Find the best matching section for deep linking
            const bestSection = this.findBestSection(result, query);
            const targetUrl = bestSection ? 
              `${result.url}#${bestSection.id}` : 
              result.url;
            const sectionInfo = bestSection ? 
              ` <span class="search-results__section">→ ${bestSection.heading}</span>` : 
              '';
            
            return `
        <div class="search-results__item">
          <a href="${targetUrl}" class="search-results__link">
            <h3 class="search-results__title">${result.title}${sectionInfo}</h3>
            <p class="search-results__summary">${this.getSearchSummary(
              result,
              query,
              bestSection
            )}</p>
          </a>
        </div>
      `;
          }
        )
        .join("");
      container.innerHTML = `
        <div class="search-results__container">
          <div class="search-results__header">
            <p class="search-results__count">${results.length} result${
        results.length !== 1 ? "s" : ""
      } for "${query}"</p>
          </div>
          ${resultsHTML}
        </div>
      `;
    }
  }

  getSearchSummary(result, query, bestSection) {
    // Use section content if available, otherwise use page content
    const searchContent = bestSection ? bestSection.content : result.content;
    const content = searchContent.toLowerCase();
    const queryLower = query.toLowerCase();
    const index = content.indexOf(queryLower);

    if (index === -1) return searchContent.substring(0, 120) + "...";

    const start = Math.max(0, index - 40);
    const end = Math.min(content.length, index + query.length + 40);
    let snippet = searchContent.substring(start, end);

    if (start > 0) snippet = "..." + snippet;
    if (end < content.length) snippet = snippet + "...";

    return snippet;
  }

  hideResults() {
    if (this.searchResults) {
      this.searchResults.style.display = "none";
    }
  }
}

// Initialize search when DOM is loaded
if (typeof window !== "undefined") {
  document.addEventListener("DOMContentLoaded", () => {
    if (window.Fuse) {
      window.__docSearchInstance = new DocumentationSearch();
    } else {
      // Load Fuse.js from CDN if not already loaded
      const script = document.createElement("script");
      script.src =
        "https://cdn.jsdelivr.net/npm/fuse.js@6.6.2/dist/fuse.min.js";
      script.onload = () => {
        window.__docSearchInstance = new DocumentationSearch();
      };
      document.body.appendChild(script);
    }
  });
}