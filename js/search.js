// Simple client-side search for ScotAccount documentation with Fuse.js fuzzy search
// Fuse.js is loaded globally via CDN and available as window.Fuse

class DocumentationSearch {
  constructor() {
    this.searchData = [];
    this.fuse = null;
    this.searchInput = null;
    this.searchResults = null;
    this.init();
  }

  async init() {
    await this.loadSearchData();
    this.setupFuse();
    this.setupSearchInterface();
    this.bindEvents();
  }

  async loadSearchData() {
    // Build search index from pages with full content
    const pages = [
      
      {
        title: "ScotAccount Technical Documentation",
        url: "/sg-identity-techdocs/",
        content: "what scotaccount provides\n\nscotaccount offers two core capabilities for government services:\n\n- user authentication - verify users have a scotaccount and receive a persistent user identifier (uuid)\n- verified attributes - access independently verified identity, address, and email data\n\nwhen a use completes the verification process their identity verified to gpg45 medium assurance level through comprehensive identity verification processes.\n\n get started quickly\n\n- quick start guide - get a working integration quickly\n- implementation guide - high level implementation guide\n- comprehensive guide - comprehensive implementation guide detailing the implementation\n- token validation - secure token handling\n- token validation module - secure token verification\n\n integration journey\n\n phase 1: planning and setup\n\n1. review architecture and requirements\n2. set up development environment\n3. configure initial authentication flow\n\n phase 2: implementation\n\n1. implement openid connect authentication\n2. add token validation\n3. integrate verified attributes\n\n phase 3: testing and deployment\n\n1. test with mock or integration environment\n2. verify all of your journeys and scenario permutations.\n3. production deployment and monitoring\n\n core features\n\n authentication\n\n- persistent user identity: each user receives a unique uuid that never changes\n- gpg45 medium assurance: high confidence in user verified identity\n- single sign-on: users authenticate once across multiple government services\n- secure by design: built on openid connect with pkce, state management, and jwt validation\n\n verified attributes\n\n| attribute    | verification method                | use cases                                     |\n| ------------ | ---------------------------------- | --------------------------------------------- |\n| identity | gpg45 medium identity verification | legal identity confirmation, age verification |\n| address  | credit reference agency checks     | service delivery, eligibility verification    |\n| email    | email confirmation loop            | service communications, account recovery      |\n| mobile   | text message confirmation loop     | service communications, account recovery      |\n\n extended verification support\n\nscotaccount uniquely handles verification processes that can minutes or days:\n\n- users can start verification on one device and verify information on their mobile.\n- progress is automatically saved and resumed\n- your service receives results when verification completes\n\n why choose scotaccount?\n\n for government services\n\n- reduced development time: no need to build authentication systems\n- enhanced security: built-in protection against common web attacks\n- compliance ready: data protection and audit capabilities included\n- verified data: access to independently validated user information\n\n for users\n\n- single account: one login for multiple government services\n- data control: users choose what information to share with each service\n- secure experience: industry-standard security with user-friendly interface\n- device flexibility: complete verification across multiple devices\n\n for technical teams\n\n- standards-based: built on openid connect\n- comprehensive documentation: complete guides and working examples\n- testing tools: mock service for rapid development and testing\n- production support: dedicated support for live service operation\n\n next steps\n\nchoose your path based on your role:\n\nnew to scotaccount? start with our getting started guide to understand the basics and set up your first integration.\n\nready to implement? jump into the complete implementation guide for detailed technical instructions.\n\nneed architecture details? review the architecture overview to understand system components and data flows.",
        summary: "what scotaccount provides\n\nscotaccount offers two core capabilities for government services:\n\n- user authentication - verify users have a scotaccount and receive a persistent user identifier (uuid)\n- ...",
        keywords: "what scotaccount provides get started quickly integration journey phase 1: planning and setup phase 2: implementation phase 3: testing and deployment core features authentication verified attributes extended verification support why choose scotaccount? for government services for users for technical teams next steps",
        sections: [{"heading":"","id":"","content":""},{"heading":"What ScotAccount Provides","id":"what-scotaccount-provides","content":"scotaccount offers two core capabilities for government services:\n\n- user authentication - verify users have a scotaccount and receive a persistent user identifier (uuid)\n- verified attributes - access independently verified identity, address, and email data\n\nwhen a use completes the verification process their identity verified to gpg45 medium assurance level through comprehensive identity verification processes."},{"heading":"Get Started Quickly","id":"get-started-quickly","content":"- quick start guide - get a working integration quickly\n- implementation guide - high level implementation guide\n- comprehensive guide - comprehensive implementation guide detailing the implementation\n- token validation - secure token handling\n- token validation module - secure token verification"},{"heading":"Integration Journey","id":"integration-journey","content":""},{"heading":"Phase 1: Planning and Setup","id":"phase-1-planning-and-setup","content":"1. review architecture and requirements\n2. set up development environment\n3. configure initial authentication flow"},{"heading":"Phase 2: Implementation","id":"phase-2-implementation","content":"1. implement openid connect authentication\n2. add token validation\n3. integrate verified attributes"},{"heading":"Phase 3: Testing and Deployment","id":"phase-3-testing-and-deployment","content":"1. test with mock or integration environment\n2. verify all of your journeys and scenario permutations.\n3. production deployment and monitoring"},{"heading":"Core Features","id":"core-features","content":""},{"heading":"Authentication","id":"authentication","content":"- persistent user identity: each user receives a unique uuid that never changes\n- gpg45 medium assurance: high confidence in user verified identity\n- single sign-on: users authenticate once across multiple government services\n- secure by design: built on openid connect with pkce, state management, and jwt validation"},{"heading":"Verified Attributes","id":"verified-attributes","content":"| attribute    | verification method                | use cases                                     |\n| ------------ | ---------------------------------- | --------------------------------------------- |\n| identity | gpg45 medium identity verification | legal identity confirmation, age verification |\n| address  | credit reference agency checks     | service delivery, eligibility verification    |\n| email    | email confirmation loop            | service communications, account recovery      |\n| mobile   | text message confirmation loop     | service communications, account recovery      |"},{"heading":"Extended Verification Support","id":"extended-verification-support","content":"scotaccount uniquely handles verification processes that can minutes or days:\n\n- users can start verification on one device and verify information on their mobile.\n- progress is automatically saved and resumed\n- your service receives results when verification completes"},{"heading":"Why Choose ScotAccount?","id":"why-choose-scotaccount","content":""},{"heading":"For Government Services","id":"for-government-services","content":"- reduced development time: no need to build authentication systems\n- enhanced security: built-in protection against common web attacks\n- compliance ready: data protection and audit capabilities included\n- verified data: access to independently validated user information"},{"heading":"For Users","id":"for-users","content":"- single account: one login for multiple government services\n- data control: users choose what information to share with each service\n- secure experience: industry-standard security with user-friendly interface\n- device flexibility: complete verification across multiple devices"},{"heading":"For Technical Teams","id":"for-technical-teams","content":"- standards-based: built on openid connect\n- comprehensive documentation: complete guides and working examples\n- testing tools: mock service for rapid development and testing\n- production support: dedicated support for live service operation"},{"heading":"Next Steps","id":"next-steps","content":"choose your path based on your role:\n\nnew to scotaccount? start with our getting started guide to understand the basics and set up your first integration.\n\nready to implement? jump into the complete implementation guide for detailed technical instructions.\n\nneed architecture details? review the architecture overview to understand system components and data flows."}]
      },
      
      {
        title: "Getting Started with ScotAccount",
        url: "/sg-identity-techdocs/getting-started/",
        content: "get up and running with scotaccount in quickly. this guide covers the essential steps to integrate scotaccount into your application.\n\n prerequisites\n\nbefore you begin, ensure you have:\n\n- development environment set up with https capability\n- ec p-256 key pair eliptic curve keys generated using openssl\n- basic understanding of openid connect\n- access to scotaccount mock and integration environment\n\nneed help with key generation? see our complete key generation guide for step-by-step instructions.\n\n quick start checklist\n\n phase 1: setup & registration\n\nbefore you begin, ensure you have completed the following configuration and preparation steps.\n\n1. generate key pair - create ec p-256 keys\n2. stored private key securely - use a secrets manager (aws secrets manager, azure key vault) or suitable alternative\n3. determine required scopes - basic authentication or verified attributes\n4. define redirect uris - set up callback urls for your service\n5. submit registration - provide details and public key the to scotaccount team\n6. receive clientid - get your unique client identifier\n\n phase 2: basic authentication\n\nthe first step in your implementation is get the authentication flow working. this will prove connectivity and\nyour applications ability to send requests to the scotaccount serveice and handle the redirects to enable the\nuser to complete the login steps necessary to complete authentication.\n\n1. implement discovery endpoint - retrieve current configuration automatically\n2. build pkce parameters - generate code verifier and challenge\n3. create authorization request - build secure authentication url\n4. implement callback handler - process authentication response\n5. build jwt client assertion - use your private key for token requests\n6. complete token exchange - get access and id tokens\n7. validate id tokens - extract and verify user identity\n\n phase 3: verified attributes (optional)\n\n1. choose additional scopes - select identity, address, or email verification\n2. handle attribute requests - manage user consent flow\n3. process attribute responses - parse verified claims data\n4. validate and store data - implement secure data handling\n\n phase 4: production deployment\n\n1. update to production endpoints - switch from integration to live urls\n2. implement monitoring - add logging and error tracking\n3. add error handling - create user-friendly error messages\n4. complete security review - recommended: run penetration testing\n\n core authentication flow\n\nthe scotaccount authentication process follows these key steps:\n\n 1. discovery configuration\n\nfirst, retrieve the current configuration:\n\nthis provides all endpoint urls and supported features. ensure your application leverages\n\n 2. generate security parameters\n\nduring the first call to scotaccount, your application is responsible for implementing the pkce client data and security required to succesfully implement an oidc client.\n\nyour application must generate:\n\n- code verifier - random string for pkce security\n- code challenge - sha256 hash of the verifier\n- state parameter - unique value to prevent csrf attacks\n- nonce - random value for replay protection\n\n 3. redirect to scotaccount\n\nbuild the authorization url and redirect users:\n\n 4. handle callback\n\nusers authenticate at scotaccount and return to your callback url:\n\ncritical: always validate the state parameter matches your original value.\n\n 5. exchange code for tokens\n\ncreate a jwt client assertion and exchange the authorization code:\n\n 6. validate and use tokens\n\nextract user information from the id token:\n\nthe  claim contains the user's persistent uuid identifier.\n\n key security requirements\n\n pkce (proof key for code exchange)\n\n- always required for all authorization requests\n- protects against authorization code interception attacks\n- must use sha256 method ()\n\n state parameter validation\n\n- generate unique state for each authorization request\n- validate on callback - reject if missing or incorrect\n- store securely during the authentication flow\n\n jwt client assertions\n\n- use your private key to sign assertions\n- include required claims: , , , , , \n- set short expiration (recommended: 60 seconds)\n\n id token validation\n\n- verify signature using scotaccount's public keys\n- check audience matches your \n- validate issuer matches scotaccount's url\n- confirm nonce matches your original value\n\n common integration patterns\n\n session management\n\n!scotaccount high-level architecture\n\nfigure: illustration of authentication flow.\n\n logout implementation\n\n next steps\n\nready for detailed implementation? move on to the implementation guide for technical details.\n\nneed verified attributes? learn about token validation and attribute handling.\n\nplanning for production? review the architecture overview to understand system components and scalability considerations.\n\nneed a deeper dive on how scotacocunt works? learn about comprehensive implementation guide to understand the details regarding the implementation.\n\n support and resources\n\n- integration support: contact the scotaccount team for technical assistance\n- testing environment: use integration endpoints for development and testing\n- documentation: refer to the comprehensive implementation guide for detailed implementation information\n- security: follow all security requirements for production deployment",
        summary: "get up and running with scotaccount in quickly. this guide covers the essential steps to integrate scotaccount into your application.\n\n prerequisites\n\nbefore you begin, ensure you have:\n\n- development...",
        keywords: "prerequisites quick start checklist phase 1: setup & registration phase 2: basic authentication phase 3: verified attributes (optional) phase 4: production deployment core authentication flow 1. discovery configuration 2. generate security parameters 3. redirect to scotaccount 4. handle callback 5. exchange code for tokens 6. validate and use tokens key security requirements pkce (proof key for code exchange) state parameter validation jwt client assertions id token validation common integration patterns session management logout implementation next steps support and resources",
        sections: [{"heading":"","id":"","content":"get up and running with scotaccount in quickly. this guide covers the essential steps to integrate scotaccount into your application."},{"heading":"Prerequisites","id":"prerequisites","content":"before you begin, ensure you have:\n\n- development environment set up with https capability\n- ec p-256 key pair eliptic curve keys generated using openssl\n- basic understanding of openid connect\n- access to scotaccount mock and integration environment\n\nneed help with key generation? see our complete key generation guide for step-by-step instructions."},{"heading":"Quick Start Checklist","id":"quick-start-checklist","content":""},{"heading":"Phase 1: Setup & Registration","id":"phase-1-setup-registration","content":"before you begin, ensure you have completed the following configuration and preparation steps.\n\n1. generate key pair - create ec p-256 keys\n2. stored private key securely - use a secrets manager (aws secrets manager, azure key vault) or suitable alternative\n3. determine required scopes - basic authentication or verified attributes\n4. define redirect uris - set up callback urls for your service\n5. submit registration - provide details and public key the to scotaccount team\n6. receive clientid - get your unique client identifier"},{"heading":"Phase 2: Basic Authentication","id":"phase-2-basic-authentication","content":"the first step in your implementation is get the authentication flow working. this will prove connectivity and\nyour applications ability to send requests to the scotaccount serveice and handle the redirects to enable the\nuser to complete the login steps necessary to complete authentication.\n\n1. implement discovery endpoint - retrieve current configuration automatically\n2. build pkce parameters - generate code verifier and challenge\n3. create authorization request - build secure authentication url\n4. implement callback handler - process authentication response\n5. build jwt client assertion - use your private key for token requests\n6. complete token exchange - get access and id tokens\n7. validate id tokens - extract and verify user identity"},{"heading":"Phase 3: Verified Attributes (Optional)","id":"phase-3-verified-attributes-optional","content":"1. choose additional scopes - select identity, address, or email verification\n2. handle attribute requests - manage user consent flow\n3. process attribute responses - parse verified claims data\n4. validate and store data - implement secure data handling"},{"heading":"Phase 4: Production Deployment","id":"phase-4-production-deployment","content":"1. update to production endpoints - switch from integration to live urls\n2. implement monitoring - add logging and error tracking\n3. add error handling - create user-friendly error messages\n4. complete security review - recommended: run penetration testing"},{"heading":"Core Authentication Flow","id":"core-authentication-flow","content":"the scotaccount authentication process follows these key steps:"},{"heading":"1. Discovery Configuration","id":"1-discovery-configuration","content":"first, retrieve the current configuration:\n\nthis provides all endpoint urls and supported features. ensure your application leverages"},{"heading":"2. Generate Security Parameters","id":"2-generate-security-parameters","content":"during the first call to scotaccount, your application is responsible for implementing the pkce client data and security required to succesfully implement an oidc client.\n\nyour application must generate:\n\n- code verifier - random string for pkce security\n- code challenge - sha256 hash of the verifier\n- state parameter - unique value to prevent csrf attacks\n- nonce - random value for replay protection"},{"heading":"3. Redirect to ScotAccount","id":"3-redirect-to-scotaccount","content":"build the authorization url and redirect users:"},{"heading":"4. Handle Callback","id":"4-handle-callback","content":"users authenticate at scotaccount and return to your callback url:\n\ncritical: always validate the state parameter matches your original value."},{"heading":"5. Exchange Code for Tokens","id":"5-exchange-code-for-tokens","content":"create a jwt client assertion and exchange the authorization code:"},{"heading":"6. Validate and Use Tokens","id":"6-validate-and-use-tokens","content":"extract user information from the id token:\n\nthe  claim contains the user's persistent uuid identifier."},{"heading":"Key Security Requirements","id":"key-security-requirements","content":""},{"heading":"PKCE (Proof Key for Code Exchange)","id":"pkce-proof-key-for-code-exchange","content":"- always required for all authorization requests\n- protects against authorization code interception attacks\n- must use sha256 method ()"},{"heading":"State Parameter Validation","id":"state-parameter-validation","content":"- generate unique state for each authorization request\n- validate on callback - reject if missing or incorrect\n- store securely during the authentication flow"},{"heading":"JWT Client Assertions","id":"jwt-client-assertions","content":"- use your private key to sign assertions\n- include required claims: , , , , , \n- set short expiration (recommended: 60 seconds)"},{"heading":"ID Token Validation","id":"id-token-validation","content":"- verify signature using scotaccount's public keys\n- check audience matches your \n- validate issuer matches scotaccount's url\n- confirm nonce matches your original value"},{"heading":"Common Integration Patterns","id":"common-integration-patterns","content":""},{"heading":"Session Management","id":"session-management","content":"!scotaccount high-level architecture\n\nfigure: illustration of authentication flow."},{"heading":"Logout Implementation","id":"logout-implementation","content":""},{"heading":"Next Steps","id":"next-steps","content":"ready for detailed implementation? move on to the implementation guide for technical details.\n\nneed verified attributes? learn about token validation and attribute handling.\n\nplanning for production? review the architecture overview to understand system components and scalability considerations.\n\nneed a deeper dive on how scotacocunt works? learn about comprehensive implementation guide to understand the details regarding the implementation."},{"heading":"Support and Resources","id":"support-and-resources","content":"- integration support: contact the scotaccount team for technical assistance\n- testing environment: use integration endpoints for development and testing\n- documentation: refer to the comprehensive implementation guide for detailed implementation information\n- security: follow all security requirements for production deployment"}]
      },
      
      {
        title: "ScotAccount Architecture Overview",
        url: "/sg-identity-techdocs/architecture/",
        content: "understanding the scotaccount architecture works is helpful for a successful integration. this page provides an overview of system components, data flows, and integration points.\n\n system overview\n\nscotaccount is part of the digital identity scotland (dis) ecosystem, providing centralised authentication and verified attribute services for scottish government digital services.\n\n high-level architecture\n\n!scotaccount high-level architecture\n\nfigure: high-level architecture of scotaccount and its integration with core dis components.\n\n core components\n\n scotaccount (authentication services)\n\npurpose: provides secure user authentication and session management\n\nkey features:\n\n- openid connect authentication provider\n- user account management and registration\n- session handling and logout\n- multi-factor authentication support\n- consent management for data sharing\n\nintegration points:\n\n- relying parties: government services requiring authentication\n- citizens: user registration and authentication interface\n- mysafe: integration for verified attribute retrieval\n- verifyyouridentity: delegation for the user verification journey\n\n verifyyouridentity (id&v services)\n\npurpose: handles identity verification processes to gpg45 medium assurance level\n\nkey features:\n\n- document scanning and verification\n- biometric selfie capture and matching\n- pep (politically exposed person) and sanctions checks\n- multi-step verification workflows\n- cross-device verification support\n\nexternal dependencies:\n\n- experian id&v: primary identity verification service\n- experian mitek: biometric verification and document scanning\n- experian peps: pep and sanctions screening\n- viaeuropa: address lookup and verification\n- gov.uk notify: sms and email delivery services\n\n mysafe (locker services)\n\npurpose: secure storage and management of verified user attributes\n\nkey features:\n\n- encrypted storage of verified identity data\n- address verification and lookup services\n- email verification and management\n- consent tracking for data sharing\n- audit logging for compliance\n\n data flow patterns\n\n basic authentication flow\n\n1. user access request: citizen attempts to access a protected resource\n2. authentication redirect: relying party redirects to scotaccount\n3. user authentication: citizen provides credentials to scotaccount\n4. token generation: scotaccount generates and returns authentication tokens\n5. resource access: relying party validates tokens and grants access\n\n verified attribute flow\n\n1. attribute request: relying party requests verified attributes with user consent\n2. verification check: scotaccount checks if verification is required\n3. verification process: if needed, user is directed to verifyyouridentity\n4. data retrieval: verified attributes are retrieved from mysafe\n5. attribute delivery: verified data is securely provided to relying party\n\n identity verification process\n\n1. verification initiation: user starts identity verification in verifyyouridentity\n2. document capture: user provides identity documents via experian mitek\n3. identity checks: documents verified against experian id&v database\n4. biometric verification: selfie capture and matching via experian mitek\n5. sanctions screening: pep and sanctions checks via experian peps\n6. result storage: verification results stored securely in mysafe\n\n security architecture\n\n authentication security\n\n- openid connect standard implementation with pkce\n- rsa 3072-bit or ec p-256 key pairs for client authentication\n- jwt tokens with short expiration times\n- state parameter validation for csrf protection\n- nonce verification for replay attack prevention\n\n data protection\n\n- encryption at rest for all stored user data\n- tls 1.3 for all data in transit\n- zero-knowledge architecture - scotaccount doesn't store verification documents\n- minimal data retention with automated deletion policies\n- consent-based data sharing with granular user control\n\n infrastructure security\n\n- cloud-native architecture with built-in resilience\n- security monitoring via sg soc integration\n- penetration testing and security audits\n- compliance with uk government security standards\n- incident response procedures and monitoring\n\n integration environments\n\n integration environment\n\n- purpose: development and testing\n- base url: \n- features: full feature set with test data\n- limitations: not for production use\n\n production environment\n\n- purpose: live service delivery\n- base url: \n- features: full production capabilities\n- requirements: formal onboarding and security review\n\n technical standards\n\n supported standards\n\n- openid connect 1.0 - core authentication protocol\n- oauth 2.0 - authorization framework\n- rfc 7636 (pkce) - security extension for public clients\n- rfc 7523 - jwt client assertion authentication\n- gpg45 - uk government identity verification standard\n\n token formats\n\n- id tokens: jwt format with user identity claims\n- access tokens: opaque tokens for api access\n- refresh tokens: encrypted tokens for session extension\n\n cryptographic requirements\n\n- signing algorithms: rs256, es256\n- key lengths: rsa 3072-bit minimum, ec p-256\n- token expiration: 15 minutes for access tokens, 1 hour for sessions\n- certificate management: automatic rotation and validation\n\n scalability and performance\n\n service availability\n\n- 99.9% uptime target for production services\n- load balancing across multiple availability zones\n- auto-scaling based on demand\n- disaster recovery with data replication\n\n performance characteristics\n\n- authentication latency: \nready to implement? review the getting started guide for step-by-step integration instructions.\n\nneed detailed technical guidance? see the complete implementation guide for comprehensive technical details.\n\nplanning token validation? check out the token validation module documentation.",
        summary: "understanding the scotaccount architecture works is helpful for a successful integration. this page provides an overview of system components, data flows, and integration points.\n\n system overview\n\nsc...",
        keywords: "system overview high-level architecture core components scotaccount (authentication services) verifyyouridentity (id&v services) mysafe (locker services) data flow patterns basic authentication flow verified attribute flow identity verification process security architecture authentication security data protection infrastructure security integration environments integration environment production environment technical standards supported standards token formats cryptographic requirements scalability and performance service availability performance characteristics compliance and governance regulatory compliance audit and monitoring next steps",
        sections: [{"heading":"","id":"","content":"understanding the scotaccount architecture works is helpful for a successful integration. this page provides an overview of system components, data flows, and integration points."},{"heading":"System Overview","id":"system-overview","content":"scotaccount is part of the digital identity scotland (dis) ecosystem, providing centralised authentication and verified attribute services for scottish government digital services."},{"heading":"High-Level Architecture","id":"high-level-architecture","content":"!scotaccount high-level architecture\n\nfigure: high-level architecture of scotaccount and its integration with core dis components."},{"heading":"Core Components","id":"core-components","content":""},{"heading":"ScotAccount (Authentication Services)","id":"scotaccount-authentication-services","content":"purpose: provides secure user authentication and session management\n\nkey features:\n\n- openid connect authentication provider\n- user account management and registration\n- session handling and logout\n- multi-factor authentication support\n- consent management for data sharing\n\nintegration points:\n\n- relying parties: government services requiring authentication\n- citizens: user registration and authentication interface\n- mysafe: integration for verified attribute retrieval\n- verifyyouridentity: delegation for the user verification journey"},{"heading":"VerifyYourIdentity (ID&V Services)","id":"verifyyouridentity-idv-services","content":"purpose: handles identity verification processes to gpg45 medium assurance level\n\nkey features:\n\n- document scanning and verification\n- biometric selfie capture and matching\n- pep (politically exposed person) and sanctions checks\n- multi-step verification workflows\n- cross-device verification support\n\nexternal dependencies:\n\n- experian id&v: primary identity verification service\n- experian mitek: biometric verification and document scanning\n- experian peps: pep and sanctions screening\n- viaeuropa: address lookup and verification\n- gov.uk notify: sms and email delivery services"},{"heading":"mySafe (Locker Services)","id":"mysafe-locker-services","content":"purpose: secure storage and management of verified user attributes\n\nkey features:\n\n- encrypted storage of verified identity data\n- address verification and lookup services\n- email verification and management\n- consent tracking for data sharing\n- audit logging for compliance"},{"heading":"Data Flow Patterns","id":"data-flow-patterns","content":""},{"heading":"Basic Authentication Flow","id":"basic-authentication-flow","content":"1. user access request: citizen attempts to access a protected resource\n2. authentication redirect: relying party redirects to scotaccount\n3. user authentication: citizen provides credentials to scotaccount\n4. token generation: scotaccount generates and returns authentication tokens\n5. resource access: relying party validates tokens and grants access"},{"heading":"Verified Attribute Flow","id":"verified-attribute-flow","content":"1. attribute request: relying party requests verified attributes with user consent\n2. verification check: scotaccount checks if verification is required\n3. verification process: if needed, user is directed to verifyyouridentity\n4. data retrieval: verified attributes are retrieved from mysafe\n5. attribute delivery: verified data is securely provided to relying party"},{"heading":"Identity Verification Process","id":"identity-verification-process","content":"1. verification initiation: user starts identity verification in verifyyouridentity\n2. document capture: user provides identity documents via experian mitek\n3. identity checks: documents verified against experian id&v database\n4. biometric verification: selfie capture and matching via experian mitek\n5. sanctions screening: pep and sanctions checks via experian peps\n6. result storage: verification results stored securely in mysafe"},{"heading":"Security Architecture","id":"security-architecture","content":""},{"heading":"Authentication Security","id":"authentication-security","content":"- openid connect standard implementation with pkce\n- rsa 3072-bit or ec p-256 key pairs for client authentication\n- jwt tokens with short expiration times\n- state parameter validation for csrf protection\n- nonce verification for replay attack prevention"},{"heading":"Data Protection","id":"data-protection","content":"- encryption at rest for all stored user data\n- tls 1.3 for all data in transit\n- zero-knowledge architecture - scotaccount doesn't store verification documents\n- minimal data retention with automated deletion policies\n- consent-based data sharing with granular user control"},{"heading":"Infrastructure Security","id":"infrastructure-security","content":"- cloud-native architecture with built-in resilience\n- security monitoring via sg soc integration\n- penetration testing and security audits\n- compliance with uk government security standards\n- incident response procedures and monitoring"},{"heading":"Integration Environments","id":"integration-environments","content":""},{"heading":"Integration Environment","id":"integration-environment","content":"- purpose: development and testing\n- base url: \n- features: full feature set with test data\n- limitations: not for production use"},{"heading":"Production Environment","id":"production-environment","content":"- purpose: live service delivery\n- base url: \n- features: full production capabilities\n- requirements: formal onboarding and security review"},{"heading":"Technical Standards","id":"technical-standards","content":""},{"heading":"Supported Standards","id":"supported-standards","content":"- openid connect 1.0 - core authentication protocol\n- oauth 2.0 - authorization framework\n- rfc 7636 (pkce) - security extension for public clients\n- rfc 7523 - jwt client assertion authentication\n- gpg45 - uk government identity verification standard"},{"heading":"Token Formats","id":"token-formats","content":"- id tokens: jwt format with user identity claims\n- access tokens: opaque tokens for api access\n- refresh tokens: encrypted tokens for session extension"},{"heading":"Cryptographic Requirements","id":"cryptographic-requirements","content":"- signing algorithms: rs256, es256\n- key lengths: rsa 3072-bit minimum, ec p-256\n- token expiration: 15 minutes for access tokens, 1 hour for sessions\n- certificate management: automatic rotation and validation"},{"heading":"Scalability and Performance","id":"scalability-and-performance","content":""},{"heading":"Service Availability","id":"service-availability","content":"- 99.9% uptime target for production services\n- load balancing across multiple availability zones\n- auto-scaling based on demand\n- disaster recovery with data replication"},{"heading":"Performance Characteristics","id":"performance-characteristics","content":"- authentication latency: < 500ms for standard flows\n- throughput: supports high-volume government services\n- caching: intelligent caching for improved response times\n- monitoring: real-time performance tracking"},{"heading":"Compliance and Governance","id":"compliance-and-governance","content":""},{"heading":"Regulatory Compliance","id":"regulatory-compliance","content":"- uk gdpr compliance for data protection\n- government security standards adherence\n- accessibility compliance (wcag 2.1 aa)\n- open government licence for documentation"},{"heading":"Audit and Monitoring","id":"audit-and-monitoring","content":"- comprehensive logging of all authentication events\n- real-time monitoring via sg soc integration\n- regular security assessments and penetration testing\n- incident response procedures and escalation"},{"heading":"Next Steps","id":"next-steps","content":"ready to implement? review the getting started guide for step-by-step integration instructions.\n\nneed detailed technical guidance? see the complete implementation guide for comprehensive technical details.\n\nplanning token validation? check out the token validation module documentation."}]
      },
      
      {
        title: "Implementation Guide",
        url: "/sg-identity-techdocs/scotaccount-guide/",
        content: "this guide provides technical implementation instructions for integrating with scotaccount. follow these steps to build secure authentication with optional verified attributes.\n\n implementation overview\n\nscotaccount integration follows a four-phase approach:\n\n1. setup & registration - generate keys and register your service\n2. basic authentication - implement openid connect authentication flow\n3. verified attributes - add identity, address, and email verification\n4. production deployment - go live with monitoring and security measures\n\n phase 1: setup & registration\n\n generate cryptographic keys\n\nec key pair:\n\n secure key storage\n\nstore private keys securely using a secrets manager. you dont have to use keyvault or secrets manager but it must not be in your application codebase:\n\naws secrets manager:\n\nazure key vault:\n\n service registration\n\nsubmit these details to the scotaccount team:\n\nrequired information:\n\n- service name and description\n- public key (from generated key pair)\n- redirect uris (where users return after authentication)\n- post-logout redirect uris (where users go after logout)\n- required scopes (see scope reference below)\n- production ip addresses (to secure token ex)\n- technical contact details\n\nscope reference:\n\n-  - required for all integrations\n-  - verified identity (gpg45 medium)\n-  - verified postal address\n-  - verified email address\n-  - verified mobile number\n\n registration response\n\nyou'll receive:\n\n- client id - your unique service identifier\n- configuration urls - integration and production endpoints\n- testing credentials - for development environment access\n\n phase 2: basic authentication\n\n!scotaccount high-level architecture\n\nfigure: illustration of authentication flow.\n\n discovery endpoint integration\n\nalways retrieve current configuration dynamically from the discovery endpoint:\n\ndiscovery endpoint url:\n\nexample discovery response:\n\nkey configuration values:\n\n-  - where to send authentication requests\n-  - where to exchange codes for tokens\n-  - public keys for token validation\n\nimplementation needed? see the discovery endpoint integration example for code implementation.\n\n pkce implementation\n\ngenerate pkce parameters for security. your application must create:\n\n- code verifier: random string between 43-128 characters (e.g., )\n- code challenge: sha256 hash of the verifier, base64url encoded (e.g., )\n- code challenge method: always \n\nimplementation needed? see the pkce implementation example for code implementation.\n\n authorization request\n\nbuild the authentication url with all required parameters:\n\nauthorization endpoint url:\n\ncomplete authorization request example:\n\neach parameter serves a specific purpose:\n\n- clientid: your unique identifier assigned during registration\n- redirecturi: where scotaccount sends users after authentication\n- responsetype: always  for the authorization code flow\n- scope: space-separated list of requested permissions\n- state: random value for csrf protection\n- nonce: random value for replay protection\n- codechallenge: sha256 hash of your code verifier, base64url encoded\n- codechallengemethod: always  for sha256\n\nimplementation needed? see the authorization request builder example for code implementation.\n\n callback handler\n\nprocess the authentication response from scotaccount:\n\nexample callback url:\n\nyour application must:\n\n1. extract the authorization code and state parameter\n2. validate the state parameter matches your stored value\n3. handle any error responses appropriately\n\nimplementation needed? see the callback handler example for code implementation.\n\n jwt client assertion\n\ncreate signed jwt for token exchange to prove your service's identity:\n\nclient assertion jwt payload example:\n\nsigned jwt example:\n\nimplementation needed? see the jwt client assertion example for code implementation.\n\n token exchange\n\nexchange authorization code for tokens:\n\ntoken endpoint url:\n\ntoken exchange request example:\n\nsuccess response example:\n\nimplementation needed? see the token exchange example for code implementation.\n\n id token validation\n\nvalidate and extract user information from the id token:\n\nexample id token (encoded):\n\ndecoded header:\n\ndecoded payload:\n\nyour application must validate:\n\n- jwt signature using scotaccount's public keys\n- token expiration time\n- issuer matches scotaccount's identifier\n- audience matches your client id\n- nonce matches your original request\n\nimplementation needed? see the id token validation example for code implementation.\n\n phase 3: verified attributes\n\n requesting additional scopes\n\nto access verified attributes, request additional scopes in a new authorisation flow when required:\n\nauthorization request with additional scopes:\n\nafter exchanging the code for an access token, request attributes:\n\nattribute request:\n\nattribute response example:\n\ndecoded claims token structure:\n\nimplementation needed? see the verified attributes examples for code implementation.\n\n phase 4: production deployment\n\n environment configuration\n\nupdate endpoints for production:\n\nproduction discovery endpoint:\n\nproduction attribute endpoint:\n\nimplementation needed? see the environment configuration example for code implementation.\n\n monitoring and logging\n\nimplement comprehensive monitoring for authentication events and metrics.\n\nimplementation needed? see the monitoring and logging example for code implementation.\n\n error handling\n\nimplement user-friendly error handling for various authentication scenarios.\n\nimplementation needed? see the error handling example for code implementation.\n\n security checklist\n\nbefore going live, verify:\n\n- [ ] private keys stored securely in secrets manager\n- [ ] https only - no http endpoints in production\n- [ ] state validation implemented for csrf protection\n- [ ] nonce validation prevents replay attacks\n- [ ] token expiration handled correctly\n- [ ] session management implemented securely\n- [ ] error logging without exposing sensitive data\n- [ ] rate limiting on authentication endpoints\n- [ ] monitoring and alerting configured\n\n complete example implementation\n\nfor a complete working example, see the comprehensive node.js/express implementation.\n\nimplementation needed? see the complete example implementation for a full working example.\n\n troubleshooting common issues\n\n invalid client assertion\n\nsymptom:  error during token exchange\nsolution: check jwt claims, expiration time, and private key format\n\n state parameter mismatch\n\nsymptom: csrf protection errors\nsolution: ensure state is generated, stored, and validated correctly\n\n token validation failures\n\nsymptom: jwt verification errors\nsolution: verify audience, issuer, and nonce claims match expected values\n\n pkce errors\n\nsymptom:  errors\nsolution: ensure code verifier and challenge are generated and used correctly\n\n support and next steps\n\nimplementation complete? review the token validation module for advanced security patterns.\n\nneed architecture details? see the architecture overview for system components and data flows.\n\nready for production? contact the scotaccount team for production onboarding and security review.",
        summary: "this guide provides technical implementation instructions for integrating with scotaccount. follow these steps to build secure authentication with optional verified attributes.\n\n implementation overvi...",
        keywords: "implementation overview phase 1: setup & registration generate cryptographic keys generate ec private key extract public key secure key storage service registration registration response phase 2: basic authentication discovery endpoint integration pkce implementation authorization request callback handler jwt client assertion token exchange id token validation phase 3: verified attributes requesting additional scopes phase 4: production deployment environment configuration monitoring and logging error handling security checklist complete example implementation troubleshooting common issues invalid client assertion state parameter mismatch token validation failures pkce errors support and next steps",
        sections: [{"heading":"","id":"","content":"this guide provides technical implementation instructions for integrating with scotaccount. follow these steps to build secure authentication with optional verified attributes."},{"heading":"Implementation Overview","id":"implementation-overview","content":"scotaccount integration follows a four-phase approach:\n\n1. setup & registration - generate keys and register your service\n2. basic authentication - implement openid connect authentication flow\n3. verified attributes - add identity, address, and email verification\n4. production deployment - go live with monitoring and security measures"},{"heading":"Phase 1: Setup & Registration","id":"phase-1-setup-registration","content":""},{"heading":"Generate Cryptographic Keys","id":"generate-cryptographic-keys","content":"ec key pair:"},{"heading":"Secure Key Storage","id":"secure-key-storage","content":"store private keys securely using a secrets manager. you dont have to use keyvault or secrets manager but it must not be in your application codebase:\n\naws secrets manager:\n\nazure key vault:"},{"heading":"Service Registration","id":"service-registration","content":"submit these details to the scotaccount team:\n\nrequired information:\n\n- service name and description\n- public key (from generated key pair)\n- redirect uris (where users return after authentication)\n- post-logout redirect uris (where users go after logout)\n- required scopes (see scope reference below)\n- production ip addresses (to secure token ex)\n- technical contact details\n\nscope reference:\n\n-  - required for all integrations\n-  - verified identity (gpg45 medium)\n-  - verified postal address\n-  - verified email address\n-  - verified mobile number"},{"heading":"Registration Response","id":"registration-response","content":"you'll receive:\n\n- client id - your unique service identifier\n- configuration urls - integration and production endpoints\n- testing credentials - for development environment access"},{"heading":"Phase 2: Basic Authentication","id":"phase-2-basic-authentication","content":"!scotaccount high-level architecture\n\nfigure: illustration of authentication flow."},{"heading":"Discovery Endpoint Integration","id":"discovery-endpoint-integration","content":"always retrieve current configuration dynamically from the discovery endpoint:\n\ndiscovery endpoint url:\n\nexample discovery response:\n\nkey configuration values:\n\n-  - where to send authentication requests\n-  - where to exchange codes for tokens\n-  - public keys for token validation\n\nimplementation needed? see the discovery endpoint integration example for code implementation."},{"heading":"PKCE Implementation","id":"pkce-implementation","content":"generate pkce parameters for security. your application must create:\n\n- code verifier: random string between 43-128 characters (e.g., )\n- code challenge: sha256 hash of the verifier, base64url encoded (e.g., )\n- code challenge method: always \n\nimplementation needed? see the pkce implementation example for code implementation."},{"heading":"Authorization Request","id":"authorization-request","content":"build the authentication url with all required parameters:\n\nauthorization endpoint url:\n\ncomplete authorization request example:\n\neach parameter serves a specific purpose:\n\n- clientid: your unique identifier assigned during registration\n- redirecturi: where scotaccount sends users after authentication\n- responsetype: always  for the authorization code flow\n- scope: space-separated list of requested permissions\n- state: random value for csrf protection\n- nonce: random value for replay protection\n- codechallenge: sha256 hash of your code verifier, base64url encoded\n- codechallengemethod: always  for sha256\n\nimplementation needed? see the authorization request builder example for code implementation."},{"heading":"Callback Handler","id":"callback-handler","content":"process the authentication response from scotaccount:\n\nexample callback url:\n\nyour application must:\n\n1. extract the authorization code and state parameter\n2. validate the state parameter matches your stored value\n3. handle any error responses appropriately\n\nimplementation needed? see the callback handler example for code implementation."},{"heading":"JWT Client Assertion","id":"jwt-client-assertion","content":"create signed jwt for token exchange to prove your service's identity:\n\nclient assertion jwt payload example:\n\nsigned jwt example:\n\nimplementation needed? see the jwt client assertion example for code implementation."},{"heading":"Token Exchange","id":"token-exchange","content":"exchange authorization code for tokens:\n\ntoken endpoint url:\n\ntoken exchange request example:\n\nsuccess response example:\n\nimplementation needed? see the token exchange example for code implementation."},{"heading":"ID Token Validation","id":"id-token-validation","content":"validate and extract user information from the id token:\n\nexample id token (encoded):\n\ndecoded header:\n\ndecoded payload:\n\nyour application must validate:\n\n- jwt signature using scotaccount's public keys\n- token expiration time\n- issuer matches scotaccount's identifier\n- audience matches your client id\n- nonce matches your original request\n\nimplementation needed? see the id token validation example for code implementation."},{"heading":"Phase 3: Verified Attributes","id":"phase-3-verified-attributes","content":""},{"heading":"Requesting Additional Scopes","id":"requesting-additional-scopes","content":"to access verified attributes, request additional scopes in a new authorisation flow when required:\n\nauthorization request with additional scopes:\n\nafter exchanging the code for an access token, request attributes:\n\nattribute request:\n\nattribute response example:\n\ndecoded claims token structure:\n\nimplementation needed? see the verified attributes examples for code implementation."},{"heading":"Phase 4: Production Deployment","id":"phase-4-production-deployment","content":""},{"heading":"Environment Configuration","id":"environment-configuration","content":"update endpoints for production:\n\nproduction discovery endpoint:\n\nproduction attribute endpoint:\n\nimplementation needed? see the environment configuration example for code implementation."},{"heading":"Monitoring and Logging","id":"monitoring-and-logging","content":"implement comprehensive monitoring for authentication events and metrics.\n\nimplementation needed? see the monitoring and logging example for code implementation."},{"heading":"Error Handling","id":"error-handling","content":"implement user-friendly error handling for various authentication scenarios.\n\nimplementation needed? see the error handling example for code implementation."},{"heading":"Security Checklist","id":"security-checklist","content":"before going live, verify:\n\n- [ ] private keys stored securely in secrets manager\n- [ ] https only - no http endpoints in production\n- [ ] state validation implemented for csrf protection\n- [ ] nonce validation prevents replay attacks\n- [ ] token expiration handled correctly\n- [ ] session management implemented securely\n- [ ] error logging without exposing sensitive data\n- [ ] rate limiting on authentication endpoints\n- [ ] monitoring and alerting configured"},{"heading":"Complete Example Implementation","id":"complete-example-implementation","content":"for a complete working example, see the comprehensive node.js/express implementation.\n\nimplementation needed? see the complete example implementation for a full working example."},{"heading":"Troubleshooting Common Issues","id":"troubleshooting-common-issues","content":""},{"heading":"Invalid Client Assertion","id":"invalid-client-assertion","content":"symptom:  error during token exchange\nsolution: check jwt claims, expiration time, and private key format"},{"heading":"State Parameter Mismatch","id":"state-parameter-mismatch","content":"symptom: csrf protection errors\nsolution: ensure state is generated, stored, and validated correctly"},{"heading":"Token Validation Failures","id":"token-validation-failures","content":"symptom: jwt verification errors\nsolution: verify audience, issuer, and nonce claims match expected values"},{"heading":"PKCE Errors","id":"pkce-errors","content":"symptom:  errors\nsolution: ensure code verifier and challenge are generated and used correctly"},{"heading":"Support and Next Steps","id":"support-and-next-steps","content":"implementation complete? review the token validation module for advanced security patterns.\n\nneed architecture details? see the architecture overview for system components and data flows.\n\nready for production? contact the scotaccount team for production onboarding and security review."}]
      },
      
      {
        title: "Comprehensive Guide",
        url: "/sg-identity-techdocs/scotaccount-complete-guide/",
        content: "quick start checklist\n\n phase 1: setup & registration\n\n- [ ] generate rsa 3072-bit or ec p-256 key pair using openssl\n- [ ] securely store private key in secrets manager (aws secrets manager, azure key vault, etc.)\n- [ ] determine required scopes based on your service needs\n- [ ] identify production ip addresses for allowlisting (if applicable)\n- [ ] define redirect and logout uris for your service\n- [ ] submit complete registration information to scotaccount team\n- [ ] receive clientid confirmation and test connectivity\n\n phase 2: basic authentication\n\n- [ ] implement discovery endpoint integration to retrieve current configuration\n- [ ] build pkce parameter generation for security\n- [ ] create authorization request builder with proper state management\n- [ ] implement callback handler with comprehensive state validation\n- [ ] build jwt client assertion creator using your private key\n- [ ] complete token exchange implementation with error handling\n- [ ] add robust id token validation and user identity extraction\n\n phase 3: verified attributes\n\n- [ ] determine which additional scopes your service requires\n- [ ] implement attribute request flow with user consent handling\n- [ ] build attribute response processor to parse verified claims\n- [ ] add comprehensive attribute data validation and storage\n\n phase 4: production deployment\n\n- [ ] update configuration to use production endpoints\n- [ ] implement comprehensive monitoring and logging\n- [ ] add user-friendly error handling and messaging\n- [ ] complete security review and penetration testing\n\n---\n\n complete authentication flow summary\n\nthis section provides a step-by-step walkthrough of the entire authentication process with actual urls and data exchanges.\n\n step 1: discovery configuration\n\nresponse provides all endpoint urls and supported features.\n\n step 2: start authentication\n\nyour application generates:\n\n- code verifier: \n- code challenge: \n- state: \n- nonce: \n\nredirect user to:\n\n step 3: user authenticates\n\nuser logs in at scotaccount and is redirected back:\n\n step 4: exchange code for tokens\n\ncreate client assertion jwt:\n\nmake token request:\n\nreceive tokens:\n\n step 5: validate id token\n\nextract and validate claims from id token:\n\n step 6: request verified attributes (optional)\n\nif you need verified data, start new flow with additional scopes:\n\nafter getting new access token, request attributes:\n\n step 7: logout\n\nwhen user logs out:\n\n---\n\n understanding scotaccount: a developer's perspective\n\nscotaccount serves as scotland's centralised digital identity provider, offering government services a secure way to authenticate citizens and access verified personal information. think of it as a trusted intermediary that handles the complex work of identity verification so your service doesn't have to build these capabilities from scratch.\n\n the value proposition for developers\n\nrather than building your own authentication system with all the associated complexity of password management, identity verification, and security compliance, scotaccount provides several key benefits. users authenticate once with scotaccount and can then access multiple government services seamlessly. your service gains access to verified identity data that has been independently validated through rigorous processes. the system provides security by design through openid connect standards, protecting against common web vulnerabilities. additionally, you benefit from built-in compliance support with data protection and audit capabilities already implemented.\n\n core concepts you need to understand\n\nthe distinction between authentication and verified attributes is fundamental to understanding how scotaccount works. authentication proves that someone is a returning user by providing you with a persistent uuid that uniquely identifies them across all interactions. verified attributes go further, providing specific information about that person that has been independently verified through various means such as credit reference checks, document verification, or email confirmation processes.\n\nscotaccount uses token-based security rather than traditional password handling. instead of your service managing user credentials, scotaccount provides cryptographically signed tokens that prove user identity and permissions. this delegation model means your service redirects users to scotaccount for authentication, then receives cryptographic proof of successful authentication without ever handling user credentials directly.\n\n why openid connect and oauth 2.0 matter\n\nopenid connect builds upon oauth 2.0 to provide a standardised approach to identity and authorisation. oauth 2.0 handles the authorisation aspect, determining what a user is allowed to access, whilst openid connect adds the identity layer, proving who the user actually is. this separation of concerns allows for more flexible and secure implementations.\n\nthe protocols include sophisticated protection mechanisms against common attack vectors. cross-site request forgery protection through state parameters, authorization code interception protection through pkce, and replay attack protection through nonce values all work together to create a robust security framework.\n\n---\n\n architecture overview\n\n!scotaccount high-level architecture\n\nfigure: high-level architecture of scotaccount and its integration with core dis components.\n\nthis architecture diagram illustrates the complete integration pattern between your government service and scotaccount. the flow begins when a user visits your service and needs to authenticate. your web application redirects them to scotaccount's authentication service, which handles the actual credential verification process.\n\nonce authentication is complete, scotaccount redirects the user back to your service with an authorization code. your backend processes this code by exchanging it for tokens through scotaccount's token service. if your service needs verified attributes about the user, you can make additional requests to the attribute service using the access token you received.\n\nthe final steps involve storing or updating user information in your database, creating an appropriate session, and granting access to your service. throughout this process, tokens are cryptographically signed jwts that you validate using scotaccount's public keys, ensuring authenticity and integrity.\n\n---\n\n phase 1: setup & registration\n\n understanding what you need to prepare\n\nbefore you can integrate with scotaccount, you need to establish a secure, trusted relationship between your service and scotaccount's infrastructure. this involves several critical components that work together to ensure secure communication and proper authorization.\n\nthe foundation of this relationship is cryptographic key management. you'll generate a public-private key pair where you keep the private key absolutely secure within your systems and provide the public key to scotaccount during registration. scotaccount uses your public key to verify that api requests are genuinely coming from your service.\n\nnetwork configuration is equally important, particularly for production deployments. scotaccount implements ip allowlisting as a security measure, meaning only requests from pre-registered ip addresses will be accepted. you'll need to identify all the ip addresses that your service will use to communicate with scotaccount.\n\nservice endpoint configuration defines how scotaccount will interact with your service during authentication flows. the redirect uri is where scotaccount will send users after they complete authentication, whilst the logout uri defines where users go after terminating their session.\n\n cryptographic key generation strategy\n\nthe security of your entire scotaccount integration depends on proper cryptographic key management. should use elliptic curve keys\n\nelliptic curve keys have smaller key sizes and good performance characteristics. the p-256 curve provides security roughly equivalent to a 3072-bit rsa keys whilst requiring significantly less computational resources. this can be particularly beneficial for high-volume services or resource-constrained environments.\n\nregardless of which key type you choose, the critical security requirement is proper private key storage. your private key must never exist in plain text outside of your application's runtime memory. use dedicated secret management systems like aws secrets manager, azure key vault, or hashicorp vault. the key should be loaded into your application at runtime and never written to configuration files, environment variables, or any persistent storage.\n\n scope planning and data requirements analysis\n\nunderstanding which scopes your service requires is fundamental to a successful integration. each scope represents a specific type of information or capability that scotaccount can provide, and requesting the right combination of scopes ensures your service gets the data it needs whilst maintaining user trust through appropriate consent requests.\n\nthe openid scope is mandatory for all integrations as it provides the basic authentication functionality and the persistent user identifier that allows you to recognise returning users. this uuid is immutable and provides a reliable way to link user sessions and data across multiple interactions.\n\nthe scotaccount.gpg45.medium scope provides verified identity information including the user's given name, family name, and date of birth. this information has been verified to gpg45 medium assurance level through a comprehensive process that includes checking identity documents and performing various verification checks. this scope is essential for services that need to verify users' legal identities.\n\nthe scotaccount.address scope provides a verified postal address that has been checked against credit reference records. this verification process confirms that the user has a genuine connection to the provided address through financial or residency records. this scope is particularly useful for services that need to verify where users live for eligibility or delivery purposes.\n\nthe scotaccount.email scope provides an email address that has been verified through an email confirmation loop during the user's scotaccount registration process. this ensures that the user actually controls the provided email address and can receive communications sent to it.\n\nthe scotaccount.mobile scope provides a mobile number that has been verified through an sms confirmation loop during the user's scotaccount registration process. this ensures that the user actually controls the provided mobile number and can receive communications sent to it.\n\nwhen planning your scope requirements, consider implementing progressive consent where you request additional scopes only when they become necessary for specific functionality rather than requesting everything upfront. this approach can improve user experience and conversion rates.\n\n registration information preparation\n\nthe registration process requires comprehensive information about your service configuration. this information is used to configure scotaccount's systems to work with your specific deployment architecture and security requirements.\n\nyour service information should include a clear service name and description that will be shown to users during authentication and consent flows. users need to understand what service they're granting access to, so this information should be clear and recognisable.\n\nnetwork configuration for production deployments must include all ip addresses that will make requests to scotaccount's apis. this typically includes your web servers, application servers, and any background services that might need to validate tokens or refresh authentication state. if your infrastructure uses load balancers, proxy servers, or content delivery networks, you need to understand how these affect the source ip addresses that scotaccount will see.\n\nservice endpoint configuration requires careful planning of your redirect and logout uris. these urls must be accessible to users' browsers and must exactly match what you register with scotaccount. even small differences in url structure, query parameters, or trailing slashes will cause authentication failures.\n\nyour cryptographic configuration section should specify whether you're using rsa or elliptic curve keys, the key length, and provide the complete public key content including all formatting and line breaks.\n\nscope requirements should list all the scopes your service needs along with a clear justification for why each scope is necessary. this helps scotaccount understand your use case and ensures that you're requesting appropriate permissions for your service's functionality.\n\n---\n\n phase 2: basic authentication implementation\n\n understanding the openid connect flow\n\nopenid connect authentication represents a sophisticated approach to solving the fundamental challenge of proving user identity in web applications. the protocol addresses many security and usability problems inherent in traditional username-and-password authentication through its delegation model.\n\nwhen a user attempts to authenticate with your service via scotaccount, they're not providing their credentials directly to your application. instead, your application redirects them to scotaccount, where they authenticate using whatever methods scotaccount supports. once authentication is complete, scotaccount provides your application with cryptographic proof that the user has been authenticated, along with a persistent identifier that allows you to recognise that user in future interactions.\n\nthis delegation model provides several crucial benefits that make it superior to traditional authentication approaches. your application never handles user passwords or other sensitive authentication credentials, reducing your security liability and simplifying compliance requirements. users benefit from a consistent authentication experience across all government services that use scotaccount, and they only need to maintain one set of authentication credentials for accessing multiple services.\n\nthe authentication flow incorporates several sophisticated protection mechanisms against common web application attacks. understanding these mechanisms helps you appreciate why certain steps in the process are mandatory and why attempting to simplify or skip steps can introduce serious security vulnerabilities.\n\n!scotaccount detailed flow diagram\n\nfigure: illustration of authentication flow.\n\nthis comprehensive flow diagram illustrates every critical step in the openid connect authentication process as implemented by scotaccount. each step serves specific security purposes and contributes to the overall integrity of the authentication system.\n\nthe process begins when a user attempts to access a protected resource in your service. your service recognises that authentication is required and initiates the openid connect flow by generating the necessary security parameters. the pkce parameters protect against authorization code interception attacks, whilst the state and nonce parameters provide protection against csrf and replay attacks respectively.\n\nyour service then redirects the user to scotaccount with a carefully constructed authorization request that includes all necessary parameters. scotaccount handles the actual authentication process, which may involve multiple steps depending on the user's account status and the security requirements.\n\nonce authentication is complete, scotaccount redirects the user back to your service with an authorization code. your service validates the state parameter to ensure the response corresponds to a request it actually made, then creates a client assertion jwt to prove its identity to scotaccount.\n\nthe token exchange step involves your service sending the authorization code, client assertion, and pkce code verifier to scotaccount's token endpoint. scotaccount validates all these components before issuing tokens that your service can use.\n\nfinally, your service validates the received tokens, extracts the user's identifier, and creates an appropriate session to grant access to the protected resource.\n\n discovery and configuration management\n\nbefore your application can authenticate users, it needs to understand scotaccount's current configuration and capabilities. this information is provided through the openid connect discovery mechanism, which returns a json document containing endpoint urls, supported authentication methods, and other configuration details.\n\ndiscovery endpoint url:\n\nexample discovery request:\n\nexample discovery response:\n\njwks endpoint for public keys:\n\nexample jwks response:\n\ndynamic configuration retrieval is essential because it allows your service to adapt to changes in scotaccount's infrastructure without requiring code updates. scotaccount may periodically update endpoint urls, rotate cryptographic keys, or modify supported authentication methods. by retrieving configuration dynamically, your service can handle these changes automatically.\n\nthe discovery endpoint provides several critical pieces of information that your application will use throughout the authentication process. the issuer field identifies scotaccount as the identity provider and must match the issuer claims in tokens that scotaccount issues. the authorizationendpoint is where you'll send users to begin the authentication process, whilst the tokenendpoint is where your application will exchange authorization codes for tokens.\n\nthe jwksuri provides access to the cryptographic keys that scotaccount uses to sign tokens. your application will use these keys to validate the authenticity and integrity of tokens it receives. the various supported fields indicate which authentication methods, token types, and cryptographic algorithms scotaccount supports, helping ensure compatibility between your implementation and scotaccount's capabilities.\n\nimplementing robust configuration management involves caching the discovery response to improve performance whilst ensuring that your application picks up configuration changes within a reasonable timeframe. error handling should include fallback to cached configuration if the discovery endpoint is temporarily unavailable, helping maintain service availability during network issues or scotaccount maintenance periods.\n\n pkce implementation strategy\n\npkce (proof key for code exchange) is a critical security enhancement that protects the authorization code flow against interception attacks. understanding how pkce works and implementing it correctly is essential for maintaining the security of your scotaccount integration.\n\npkce addresses a specific vulnerability in the oauth 2.0 authorization code flow where an attacker might intercept the authorization code during the redirect back to your application. in traditional oauth 2.0, this authorization code could then be exchanged for tokens by anyone who possesses it.\n\npkce solves this problem by introducing a cryptographic challenge-response mechanism. your application generates a random code verifier, calculates a corresponding code challenge using sha256 hashing, and includes the code challenge in the initial authorization request. the authorization code that scotaccount returns is cryptographically bound to this code challenge.\n\nwhen your application exchanges the authorization code for tokens, it must provide the original code verifier. scotaccount can then verify that the code verifier matches the code challenge from the original request, proving that the token exchange request is coming from the same application that initiated the authorization flow.\n\nthe security of pkce depends entirely on the unpredictability of the code verifier. the code verifier must be generated using a cryptographically secure random number generator and must have sufficient entropy to resist brute-force attacks. the code verifier should be between 43 and 128 characters long and use the base64url character set.\n\nthe code challenge is calculated by taking the sha256 hash of the code verifier and encoding it using base64url encoding. this one-way transformation ensures that even if an attacker intercepts the code challenge, they cannot derive the original code verifier.\n\n state management for csrf protection\n\nthe state parameter provides protection against cross-site request forgery attacks by ensuring that authorization responses correspond to requests that your application actually initiated. implementing state management correctly is crucial for maintaining the security of the authentication flow.\n\ncsrf attacks occur when an attacker tricks a user into performing actions they didn't intend by exploiting their existing authenticated sessions. in the context of openid connect, this could involve an attacker initiating an authentication flow and then tricking a victim into completing it, potentially allowing the attacker to gain access to the victim's account.\n\nthe state parameter prevents this attack by creating a unique, unpredictable value for each authentication request. your application generates this value and includes it in the authorization request. scotaccount returns the same state value in the authorization response, allowing your application to verify that the response corresponds to a request it actually made.\n\nproper state management involves generating cryptographically secure random state values that cannot be predicted by attackers. each state value should be single-use and have a limited lifetime to prevent replay attacks. your application should store the state value securely during the authentication flow and validate it when processing the authorization response.\n\nthe state validation step must occur before any other processing of the authorization response. if the state value doesn't match what your application originally generated, the entire response should be rejected as potentially malicious.\n\n authorization request construction\n\nthe authorization request is the first step in the authentication flow where your application redirects the user to scotaccount for authentication. constructing this request correctly is crucial for both security and functionality.\n\nauthorization endpoint url:\n\ncomplete authorization request example:\n\neach parameter in the authorization request serves a specific purpose:\n\n- clientid: your unique identifier assigned during registration (e.g., )\n- redirecturi: where scotaccount sends users after authentication. must exactly match your registered uri\n- responsetype: always  for the authorization code flow\n- scope: space-separated list of requested permissions.  is mandatory\n- state: random value for csrf protection (you generate this)\n- nonce: random value for replay protection (you generate this)\n- codechallenge: sha256 hash of your code verifier, base64url encoded\n- codechallengemethod: always  for sha256\n\nexample with additional scopes:\n\nwhat happens next:\n\n1. user is redirected to scotaccount's login page\n2. user authenticates and grants consent\n3. scotaccount redirects back to your redirecturi with:\n   \n\n token exchange and client authentication\n\nthe token exchange step is where your application proves its identity to scotaccount and exchanges the authorization code for usable tokens. this critical step requires your service to create a special jwt called a \"client assertion\" that acts like a digital signature, proving you are who you claim to be.\n\ntoken endpoint url:\n\nstep 1: create your client assertion jwt\n\nyour service creates a jwt with these claims:\n\nthis jwt is signed with your private key, resulting in something like:\n\nstep 2: make the token exchange request\n\nrequest parameters explained:\n\n- granttype: always \n- code: the authorization code from the callback\n- redirecturi: must match exactly what you used in the authorization request\n- clientassertiontype: always this exact urn value\n- clientassertion: your signed jwt proving your identity\n- codeverifier: the original pkce verifier you generated\n\nstep 3: receive tokens\n\nsuccess response:\n\nerror response example:\n\nthe key security aspects of this exchange:\n\n- your private key never leaves your system\n- the client assertion proves only you could have made this request\n- the code verifier proves you initiated the original flow\n- all parameters are validated together for maximum security\n\n token validation and user identity extraction\n\nonce your application receives tokens from scotaccount, it must validate them thoroughly before trusting their contents. token validation is a critical security step that ensures the tokens are authentic, haven't been tampered with, and are intended for your application.\n\njson web tokens used by scotaccount consist of three parts separated by dots: the header, payload, and signature. understanding this structure through a concrete example helps clarify what you're validating and why each step matters.\n\nexample id token (encoded):\n\nthis encoded token contains three base64url-encoded sections separated by dots. let's examine what's inside by decoding each section:\n\nheader (decoded):\n\nthe header tells us that this token is signed using rs256 (rsa with sha-256) and identifies which key was used to sign it through the kid (key id) field. your application will use this kid to look up the correct public key from scotaccount's jwks endpoint.\n\npayload (decoded):\n\nthe payload contains the actual claims about the authentication event. each field serves a specific purpose in the validation process:\n\n- sub (subject): this is the persistent user identifier (uuid) that uniquely identifies the user across all scotaccount services. this is the primary piece of information you'll extract and store.\n- aud (audience): your client id, confirming this token was issued specifically for your application.\n- iss (issuer): scotaccount's identifier, which must match the issuer from the discovery document.\n- exp (expiration): unix timestamp indicating when this token expires (15 minutes after issuance).\n- iat (issued at): unix timestamp of when the token was created.\n- nonce: the random value you provided in the authorization request, used to prevent replay attacks.\n- jti (jwt id): a unique identifier for this specific token.\n- sid (session id): scotaccount's session identifier, used for session management and logout.\n\nsignature:\nthe third part is the cryptographic signature that proves the token hasn't been tampered with and was genuinely issued by scotaccount. this signature is created using scotaccount's private key and can be verified using their public key.\n\nproper jwt validation involves several distinct steps, each of which protects against different types of attacks. signature verification ensures the token hasn't been tampered with and was indeed issued by scotaccount. this involves retrieving scotaccount's current public keys from the jwks endpoint and using them to verify the token's cryptographic signature.\n\nthe validation process involves several critical steps that must be performed in the correct order to ensure security. first, your service parses the jwt to extract the header and payload sections. using the key identifier from the header, you retrieve the appropriate public key from scotaccount's jwks endpoint. this key is then used to verify the cryptographic signature, ensuring the token hasn't been tampered with and was genuinely issued by scotaccount.\n\nafter signature verification, you must validate each claim in the token. the expiration time must be checked to ensure the token is still valid. the issuer must match scotaccount's identifier exactly as provided in the discovery document. the audience must be your client id, confirming this token was issued specifically for your service. the nonce must match the value your service provided in the original authorization request, preventing replay attacks.\n\nsuccessful validation confirms that the token is authentic, current, and intended for your service. the subject claim then provides the persistent user identifier that your service uses to recognise this user in all future interactions. this uuid remains constant for each user across all their sessions and interactions with your service.\n\nopenid connect specific validation includes verifying the nonce claim to prevent replay attacks. the nonce value in the token must match the nonce value your application included in the original authorization request. additionally, the subject claim provides the persistent user identifier that your application will use to recognise the user in future interactions.\n\nonce validation is complete, you can extract the user's persistent identifier from the sub claim and use it to establish or update the user's session within your application. this uuid uniquely and persistently identifies the user across all interactions with scotaccount-integrated services and serves as the foundation for user identity management in your service.\n\n---\n\n phase 3: verified attributes integration\n\n understanding attribute requests\n\nwhen your service needs verified information about users beyond their basic identity, you request additional scopes in the authentication flow. scotaccount will then guide users through appropriate consent screens and return verified data that has been independently validated through various verification processes.\n\nthe key principle behind verified attributes is user consent and data minimisation. users must be present and actively consent to sharing each type of verified information. scotaccount cannot provide verified attributes through background api calls or long-lived tokens - the user must be actively involved in the process each time new attributes are requested.\n\nthis consent-based approach serves both privacy and security purposes. users maintain control over what information they share with each service, and services are encouraged to request only the data they actually need. the verification processes that scotaccount uses to validate attributes are rigorous and involve multiple independent checks to ensure accuracy.\n\nthis flow diagram illustrates the complete process for requesting and receiving verified attributes from scotaccount. the process begins when a user attempts to access functionality that requires verified information beyond basic authentication.\n\nyour service first checks whether the user already has the required attributes stored locally. if the necessary verified information is already available, your service can proceed immediately without requiring additional authentication or consent steps.\n\nif additional attributes are needed, your service initiates a new authentication flow that includes the additional scopes for the required attributes. this triggers scotaccount's consent process, where users are clearly informed about what information is being requested and why.\n\nupon user consent, scotaccount provides an authorization code that your service exchanges for tokens, including an access token specifically scoped for the requested attributes. this access token is then used to make a request to scotaccount's attribute service, which returns the verified information in the form of a signed jwt.\n\nthe attribute jwt contains not only the verified claims but also detailed verification metadata that describes how each piece of information was verified and what level of assurance it carries. your service validates this jwt using the same cryptographic verification process used for id tokens.\n\n attribute verification levels and trust\n\nunderstanding the different verification methods and assurance levels for each type of attribute helps you make informed decisions about which attributes to request and how to use the returned information appropriately.\n\ngpg45 medium identity verification represents a substantial level of assurance about a user's legal identity. this process involves checking official identity documents, performing various database checks, and applying sophisticated fraud detection techniques. when you receive identity information with gpg45 medium verification, you can have high confidence that it represents the user's actual legal identity as it appears on official documentation.\n\naddress verification through credit reference agencies provides strong assurance that the user has a genuine connection to the provided address. this verification process checks the address against multiple credit reference databases to confirm that the user has had a financial or legal connection to that address. while this doesn't necessarily mean they currently live there, it does provide significant assurance about the legitimacy of the address information.\n\nemail verification through confirmation loops provides assurance that the user controls the provided email address at the time of verification. this process involves sending a confirmation email with a unique link or code that the user must access to complete the verification. while simpler than other verification methods, this still provides valuable assurance for services that need to communicate with users via email.\n\neach verified attribute includes metadata that describes the verification process used, the confidence level achieved, and the timestamp of when the verification was performed. this metadata allows your service to make informed decisions about how to use the verified information and what level of trust to place in it.\n\n progressive consent and user experience\n\nimplementing verified attributes effectively requires careful consideration of the user experience and the timing of attribute requests. progressive consent, where you request additional attributes only when they become necessary for specific functionality, generally provides a better user experience than requesting all possible attributes upfront.\n\ncritical design consideration: extended gpg45 verification processes\n\nthe gpg45 medium identity verification process duration is entirely guided by the user's ability to complete the required steps. users may take days, weeks, or even longer to provide necessary documents and complete verification steps. this creates specific challenges that services must design for:\n\nhow scotaccount handles extended verification:\n\n1. user initiates verification: user begins gpg45 medium verification through your service's request\n2. scotaccount saves progress: scotaccount maintains the user's progress through verification steps\n3. time passes: the user may take any amount of time to complete verification steps\n4. sessions expire: your service session, scotaccount session, and all tokens will have expired\n5. user returns and logs in: when the user authenticates with scotaccount again, scotaccount automatically returns them to their saved point in the verification journey\n6. service perspective: your service initiated an authentication flow but never received a callback\n\nfrom your service's perspective, this appears as an abandoned authentication flow. however, scotaccount is maintaining the user's verification progress and will continue the process when they return.\n\ncross-browser and cross-device challenges:\n\nusers may start verification on one device/browser and complete it on another. this creates additional complexity:\n\n- state parameters won't match: the state parameter your service generated on the original browser won't exist in the new browser session\n- local session data is lost: any data stored in the original browser session isn't accessible\n- pkce parameters are missing: the code verifier stored in the original session is not available\n\nrecommended patterns for handling extended verification:\n\n1. track verification initiation\nrecord when users start verification processes so you can provide appropriate messaging when they return:\n\n- store the user id and timestamp when verification is initiated\n- track which scopes were requested\n- save any context about what the user was trying to accomplish\n\n2. design for stateless returns\nsince users may return on different devices, avoid relying on session state:\n\n- don't depend on the original state parameter being available\n- store important context server-side linked to the user id\n- be prepared to handle authentication callbacks without matching state parameters\n\n3. implement intelligent return handling\nwhen users authenticate without completing a previous flow:\n\n- check if they have previously initiated verification\n- provide clear messaging about continuing their verification\n- offer options to check status or proceed with limited functionality\n\n4. clear communication patterns\n\n- before starting: \"identity verification can take as long as you need. you can return anytime to continue where you left off.\"\n- when returning: \"welcome back! your identity verification is in progress. would you like to continue verifying your identity or proceed with limited access?\"\n- status checking: \"you started identity verification on [date]. continue verification to unlock full access.\"\n\n5. handle missing state gracefully\nwhen receiving callbacks without matching state:\n\n- log the event for security monitoring\n- check if the user has pending verification requests\n- provide appropriate options rather than showing errors\n\nexample user journeys:\n\nscenario 1: same device return\n\n- day 1: user starts application on laptop → begins verification\n- day 3: user returns on same laptop → scotaccount continues verification\n- day 4: user completes verification → your service receives verified attributes\n\nscenario 2: cross-device journey\n\n- day 1: user starts on mobile phone → begins verification\n- day 2: user continues on desktop computer → scotaccount recognises them and continues\n- day 5: user completes on tablet → your service receives callback on different device\n\nimportant considerations:\n\n- the verification duration is entirely user-controlled\n- scotaccount handles all progress saving and continuation\n- your service must handle callbacks that arrive days/weeks after initiation\n- cross-device flows mean you cannot rely on session state\n- design your user experience to accommodate these realities\n\nconsider a typical government service scenario where users might initially need only basic authentication to access general information, but later require identity verification to submit applications or access personalised services. by implementing progressive consent, you can allow users to access the general functionality immediately whilst requesting additional verified attributes only when they're actually needed.\n\nthis approach has several benefits for both user experience and conversion rates. users are more likely to grant consent for data sharing when they understand the specific purpose for which the information will be used. requesting attributes in context, when their necessity is clear, builds trust and reduces the likelihood of users abandoning the authentication process.\n\nhowever, progressive consent also requires careful implementation to avoid creating frustrating user experiences. your service should clearly communicate when additional verification will be required and provide smooth transitions between different levels of access.\n\n attribute data structure and validation\n\nverified attributes are returned in a structured json format within a signed jwt that includes both the actual attribute data and comprehensive verification metadata. understanding this structure is essential for properly extracting and validating the information your service receives.\n\nattributes endpoint url:\n\nattribute request example:\n\nimportant: the dis-client-assertion header contains a new client assertion jwt with the audience set to the attributes endpoint url.\n\nattribute response example:\n\ndecoded claims token structure:\n\nkey points about attribute responses:\n\n1. partial success is possible: if you request multiple scopes, scotaccount returns as many as it can verify. you might receive 0 to n attributes back.\n\n2. verification metadata: each attribute includes detailed verification information:\n\n   - : whether verification succeeded, had warnings, or failed\n   - : the standards framework used (typically \"uktfida\")\n   - : the assurance level achieved\n   - : how the data was verified\n   - : when verification occurred\n   - : who performed the verification\n\n3. error responses:\n   - : user has no verified attributes\n   - : invalid access token or client assertion\n   - : token doesn't have required scopes\n\nthe verified claims array contains one or more attribute objects, each corresponding to a scope that was requested and successfully provided. each attribute object includes the scope identifier, the actual claims data, and detailed verification information.\n\nwhen processing attribute data, your service should validate not only the cryptographic signature of the jwt but also examine the verification metadata to ensure that the attributes meet your specific requirements for assurance level and recency. different use cases may require different levels of verification, and the metadata provides the information needed to make these determinations.\n\n attribute storage and lifecycle management\n\nonce your service receives verified attributes, you need to consider how to store and manage this information throughout its lifecycle. verified attributes represent sensitive personal information that requires appropriate protection and management practices.\n\nconsider implementing appropriate data retention policies based on your service's specific requirements and legal obligations. some verified attributes may remain valid for extended periods, whilst others may require periodic re-verification. the verification metadata can help inform these decisions by providing information about when attributes were last verified.\n\nimplement secure storage practices that protect verified attributes both at rest and in transit. this includes using appropriate encryption, access controls, and audit logging to ensure that verified information is only accessed by authorised personnel for legitimate purposes.\n\nconsider the relationship between scotaccount's verification and your service's ongoing data management needs. while scotaccount provides initial verification of attributes, your service may need to implement additional validation or updating processes based on its specific requirements and use patterns.\n\nplan for scenarios where users may need to update their verified information or where verification status may change over time. your service should be able to handle requests for re-verification and should provide clear guidance to users about how to update their information when necessary.\n\n---\n\n testing strategy & mock service usage\n\n understanding testing environments\n\nscotaccount provides a comprehensive integration/sandpit environment that contains two distinct deployments to support different phases of your integration testing. understanding the purpose and capabilities of each deployment helps you plan an effective testing strategy that builds confidence in your integration before production deployment.\n\nmock service deployment\n\nthe mock service is a completely isolated test application designed to allow you to test the functionality and interactions of the scotaccount service without the complexity of full data verification or live data management. this service enables rapid development and testing cycles by providing predictable responses for all the standard oidc flows.\n\nmock service url:\n\nthe mock service's key benefits include:\n\n- no need to create or manage test user accounts\n- predictable responses for testing different code paths\n- ability to exercise all authentication and attribute flows\n- fast response times for automated testing\n- detailed documentation of limitations and behaviour at the service url\n\nthe mock service is ideal for:\n\n- initial development of your integration\n- automated testing in ci/cd pipelines\n- testing error handling and edge cases\n- demonstrating journey completeness\n- rapid iteration during development\n\nproduction-like environment\n\nthe second deployment is a fully functional, production-like environment that provides a representative experience of the live scotaccount service. this environment uses the same infrastructure, protocols, and security measures as production, giving you high confidence that integrations tested here will work correctly when you go live.\n\nthe production-like environment provides:\n\n- full oidc protocol implementation\n- real authentication flows with test accounts\n- complete security measures including ip allowlisting\n- actual consent and verification user interfaces\n- the same data structures and response formats as production\n\nkey limitation to note:\n\n- identity verification always returns successful/verified status\n- this makes it difficult to test failed verification scenarios\n- plan your testing accordingly to work around this limitation\n\n testing strategy progression\n\nan effective testing strategy progresses through both deployments in a structured manner, building confidence at each stage before moving to the next. think of this as climbing a ladder where each rung provides the foundation for safely reaching the next level.\n\nunderstanding each testing phase:\n\nphase 1: development environment - this is where you build your foundation. the mock service acts as your safe practice space where you can make mistakes without consequences. your unit tests verify individual components work correctly, while integration tests ensure these components play nicely together. the mock service responds instantly and predictably, allowing you to iterate quickly and build comprehensive test coverage.\n\nphase 2: integration validation - here you prove your integration works with the real scotaccount protocols. the production-like environment provides authentic oidc flows, actual user interfaces, and full security measures. you'll run end-to-end tests that mirror real user journeys, specific user journey tests for different scenarios, and security tests to validate your implementation. remember that identity verification always succeeds here, so plan your error handling based on specifications rather than test results.\n\nphase 3: production deployment - this is where your integration meets real users. smoke tests verify basic functionality immediately after deployment, while continuous monitoring watches for issues that only appear under real-world conditions. here you'll encounter actual verification outcomes, complete security controls, and the full complexity of production traffic.\n\nthe downward flow between phases represents increasing realism and decreasing flexibility. you cannot skip phases because each one validates different aspects of your integration. starting in production would be like learning to swim by jumping into the ocean - theoretically possible but unnecessarily risky.\n\n mock service implementation guide\n\nthe mock service simulates all scotaccount endpoints and responses, allowing you to develop and test your integration without managing test data. think of it as a practice environment where you can make mistakes safely and learn how the service behaves. visit the mock service url for comprehensive documentation about its capabilities and limitations.\n\nusing the mock service effectively:\n\nthe beauty of the mock service lies in its simplicity. you don't need to register your client or provide ip addresses, which means you can start testing immediately. this rapid feedback loop is invaluable during initial development when you're still figuring out how all the pieces fit together.\n\nthe mock service provides predictable responses, which might seem artificial but serves an important purpose. when you're building your integration, you need to know that a specific request will always produce a specific response. this predictability allows you to build robust automated tests that won't fail due to external factors like network issues or data changes.\n\nunderstanding mock service boundaries:\n\nwhile the mock service is excellent for functional testing, it deliberately relaxes some security validations. for instance, it may not fully validate client assertion signatures or enforce strict parameter checking. this isn't a limitation but rather a feature that allows you to focus on getting the integration flow correct before worrying about every security detail.\n\nexample mock service endpoints follow the same pattern as production:\n\n- discovery: \n- authorization, token, and other endpoints: check the discovery response for exact urls\n\nthe mock service documentation (available at the service url) provides detailed information about which validations are relaxed and how responses differ from production behaviour. this transparency helps you understand exactly what you're testing and what you'll need to validate later in the production-like environment.\n\n production-like environment testing\n\nonce your integration works correctly with the mock service, you're ready for the production-like environment. this transition is like moving from a flight simulator to an actual aircraft with an instructor - everything is real except for certain safety constraints.\n\nkey testing areas and what makes them important:\n\nthe production-like environment forces you to handle real-world complexity. your client assertions must be properly signed, your pkce parameters must be correctly generated, and your state management must be bulletproof. this is where you discover if your error handling can cope with actual scotaccount responses rather than simulated ones.\n\ntesting the consent flows with real ui is particularly valuable because it reveals user experience issues that the mock service cannot simulate. you'll see exactly how long each step takes, where users might get confused, and how your application needs to handle users who take unexpected paths through the authentication process.\n\nworking around the verification limitation:\n\nthe fact that gpg45 verification always succeeds in this environment is a significant limitation, but there are strategies to work around it. design your error handling based on the technical specification rather than what you can test. use defensive programming principles - assume that verification can fail and build your system to handle that gracefully, even if you can't test it directly.\n\nconsider creating a \"verification failed\" simulation in your own code during testing. you can temporarily modify your attribute parsing logic to treat successful verifications as failures, allowing you to test your error handling paths. just remember to remove this simulation before moving to production.\n\n recommended testing approach\n\nstarting with the mock service allows you to build momentum quickly. you can create a comprehensive test suite that exercises every path through your integration, giving you a safety net for future changes. focus on getting the happy paths working first, then systematically add error handling for each type of failure the specification describes.\n\nwhen you move to the production-like environment, approach it with fresh eyes. run through your test scenarios manually first to get a feel for the real system. pay attention to timing - how long do redirects take? how quickly do tokens expire? these real-world characteristics will inform how you design your user experience.\n\ndocument any scenarios you cannot test fully, particularly around verification failures. create a plan for monitoring these scenarios in production so you can respond quickly if issues arise. remember that the first time some error conditions occur will be in production, so comprehensive logging and alerting become your safety net.\n\nthis methodical progression from mock to production-like to production ensures that when you go live, you've tested everything that can be tested and have plans in place for everything that cannot.\n\n---\n\n---\n\n quick reference\n\n essential endpoints\n\nthe scotaccount service provides different endpoints for different environments, each serving specific purposes in your integration journey. understanding which endpoints to use in which circumstances is crucial for successful integration.\n\nintegration environment: the integration environment uses endpoints under the authz.integration.scotaccount.service.gov.scot domain and provides a complete scotaccount implementation with test data. this environment is perfect for development, testing, and final validation before production deployment. the discovery endpoint provides current configuration information including all other endpoint urls.\n\nproduction environment: the production environment uses endpoints under the authz.scotaccount.service.gov.scot domain and provides the live scotaccount service with real user data and full security controls. this environment requires ip allowlisting and uses production-grade security measures.\n\nmock environment: the mock environment uses endpoints under the mock-dis.main.integration.scotaccount.service.gov.scot domain and provides simulated responses for development and automated testing. this environment doesn't require real authentication and can simulate various success and failure scenarios.\n\n scope reference and data mapping\n\nunderstanding exactly what data each scope provides helps you request appropriate permissions and handle the returned information correctly in your service.\n\nopenid scope: this mandatory scope provides basic authentication functionality and returns a persistent user identifier in the sub claim of the id token. this uuid uniquely identifies the user across all scotaccount-integrated services and never changes for a given user. the authentication process verifies the user's identity to gpg45 medium assurance level.\n\nscotaccount.gpg45.medium scope: this scope provides verified identity information including the user's given name, family name, and date of birth as they appear on official identity documents. the verification process involves checking identity documents and performing various database checks to achieve gpg45 medium assurance level.\n\nscotaccount.address scope: this scope provides a verified postal address that has been checked against credit reference records. the returned address includes detailed components such as building numbers, street names, locality information, and postal codes, along with verification metadata describing the validation process.\n\nscotaccount.email scope: this scope provides an email address that has been verified through an email confirmation loop during the user's scotaccount registration. the verification process confirms that the user controls the provided email address and can receive messages sent to it.\n\n token lifetimes and usage patterns\n\nunderstanding token lifetimes helps you implement appropriate caching, refresh, and error handling strategies in your integration.\n\nauthorization code: authorization codes are single-use tokens with a 10-minute lifetime that must be exchanged for usable tokens immediately after being received. these codes cannot be stored or reused and should be processed as soon as they're received from the authorization callback.\n\naccess token: access tokens have a 15-minute lifetime and are used for making api requests to scotaccount's attribute service. these tokens are scoped to specific attributes and cannot be used beyond their intended scope or lifetime.\n\nid token: id tokens have a 15-minute lifetime and contain user identity claims that have been cryptographically signed by scotaccount. these tokens should be validated immediately upon receipt and the claims extracted for use in your application.\n\nrefresh token: refresh tokens have a 15-minute lifetime and provide limited token refresh capabilities. the refresh token mechanism in scotaccount is primarily designed for extending access to attribute apis rather than long-term session management.\n\nsession: service session duration is 1 hour.\n\n common error codes and resolution\n\nunderstanding common error scenarios and their resolutions helps you implement effective error handling and provide appropriate user guidance.\n\nauthorization endpoint errors (302 redirect):\n\ncommon authorization errors:\n\n- : missing or invalid parameters (check scopes, redirecturi)\n- : user cancelled or denied consent\n- : requested scope not supported or not granted to your client\n- : scotaccount internal error\n\ntoken endpoint errors (400/401 json response):\n\ncommon token errors:\n\n- : your clientid is not recognised or client assertion validation failed\n- : authorization code expired, already used, or doesn't match your client\n- : missing required parameters or malformed request\n- : your client isn't authorised for the requested grant type\n\nattribute endpoint errors:\n\n- : access token expired or client assertion invalid\n- : token lacks required scopes for requested attributes\n- : no verified attributes available for the user\n- : scotaccount service issue\n\nresolution guide:\n\ninvalidclient errors typically indicate that your clientid is not recognised by scotaccount or that your client authentication is failing. verify that:\n\n- your clientid matches exactly what was registered\n- your client assertion jwt is properly signed with your registered private key\n- the audience claim in your client assertion matches the endpoint url exactly\n- your client assertion hasn't expired (check the 6-month expiry)\n\ninvalidrequest errors indicate that required parameters are missing or malformed in your requests. check that:\n\n- all mandatory parameters are present and properly formatted\n- redirect uri matches exactly (including trailing slashes)\n- scopes are space-separated and url-encoded\n- pkce parameters are properly generated and matched\n\naccessdenied errors occur when users deny consent for authentication or data sharing. handle these gracefully by:\n\n- providing clear explanation of why permissions are needed\n- offering alternative ways to use your service without full permissions\n- not repeatedly requesting the same permissions in a loop\n\ninvalidgrant errors typically indicate authorization code issues. ensure that:\n\n- codes are exchanged immediately (within 10 minutes)\n- each code is only used once\n- the redirecturi in token exchange matches the authorization request\n- the pkce verifier matches the original challenge\n\n---\n\n phase 4: production deployment\n\n understanding production environment differences\n\nmoving from development and testing to production involves several important changes that affect both security and operational considerations. the production environment implements stricter security controls and requires additional configuration that isn't necessary during development.\n\nthe most significant difference is the ip allowlisting requirement for production deployments. unlike the integration environment where any ip address can connect for testing purposes, production requires that you register all ip addresses that will communicate with scotaccount's apis. this security measure helps protect against unauthorised access and provides an additional audit trail for all api communications.\n\nproduction endpoints use different urls from the integration environment, and you'll need to update your configuration accordingly. your redirect uris must use https in production (localhost http uris are not permitted), and your logout uris must also be publicly accessible https endpoints.\n\n production configuration checklist\n\nenvironment configuration updates:\n\n- [ ] update discovery endpoint to production url\n- [ ] update all redirect uris to use https production urls\n- [ ] update logout uri to production https endpoint\n- [ ] generate new cryptographic keys for production (never reuse development keys)\n- [ ] register production public key with scotaccount\n- [ ] provide complete list of production ip addresses for allowlisting\n\nsecurity implementation requirements:\n\n- [ ] store private keys in dedicated secret management systems\n- [ ] implement comprehensive logging for all authentication events\n- [ ] add monitoring for authentication success/failure rates\n- [ ] configure alerting for unusual authentication patterns\n- [ ] implement session timeout handling appropriate for your service\n- [ ] add comprehensive error handling with user-friendly messages\n\noperational readiness:\n\n- [ ] test complete authentication flows in production environment\n- [ ] verify all error scenarios handle gracefully\n- [ ] confirm monitoring and alerting systems are working\n- [ ] document support procedures for common user issues\n- [ ] establish communication channels with scotaccount support team\n- [ ] plan for handling service outages or maintenance windows\n\n production endpoints\n\n| service       | production endpoint                                                           |\n| ------------- | ----------------------------------------------------------------------------- |\n| discovery     |  |\n| authorization | retrieved from discovery (typically )                             |\n| token         | retrieved from discovery (typically )                                 |\n| jwks          | retrieved from discovery (typically )                             |\n| attributes    | retrieved from discovery (typically )                     |\n\n monitoring and operational considerations\n\nimplementing comprehensive monitoring helps ensure reliable operation and quick identification of issues that might affect user experience. authentication services require specific monitoring approaches that track both technical metrics and user experience indicators.\n\ncritical metrics to monitor:\n\n- authentication success and failure rates over time\n- token validation errors and their frequency\n- discovery endpoint availability and response times\n- jwks endpoint accessibility and key rotation events\n- user session duration and timeout patterns\n- error rates by error type to identify common issues\n\nalerting strategy:\nconfigure alerts for metrics that indicate immediate problems requiring attention. authentication failure rates above normal baselines might indicate service issues or potential security concerns. discovery endpoint failures prevent new authentication flows from starting. jwks endpoint issues prevent token validation and can cause widespread authentication failures.\n\nuser experience monitoring:\ntrack user journey completion rates through authentication flows to identify points where users commonly abandon the process. monitor the time users spend on scotaccount authentication pages, as unusually long times might indicate usability issues or service performance problems.\n\nsecurity event logging:\nmaintain comprehensive logs of all authentication events for both operational and security purposes. log successful authentications with user identifiers and timestamps, failed authentication attempts with error details, and any unusual patterns that might indicate security issues. ensure logs include sufficient detail for troubleshooting whilst protecting sensitive user information.\n\n support and incident response\n\nestablish clear procedures for handling authentication-related user issues and service incidents. users may experience authentication problems due to various factors including expired sessions, browser issues, or temporary service disruptions.\n\ncommon user issues and resolutions:\nauthentication failures often result from expired sessions, where users have remained on your service longer than scotaccount's session lifetime. implement clear messaging that explains when users need to re-authenticate and provides easy ways to restart the authentication process.\n\nbrowser compatibility issues can affect the authentication flow, particularly with older browsers or those with strict security settings. provide guidance for users about supported browsers and common browser configuration issues that might prevent successful authentication.\n\nservice incident response:\ndevelop procedures for handling scotaccount service outages or degraded performance. consider implementing fallback authentication methods for critical services, though these should be designed carefully to maintain security standards. establish communication procedures with the scotaccount operations team for reporting and coordinating resolution of service issues.\n\nplanned maintenance coordination:\nwork with the scotaccount team to understand planned maintenance schedules that might affect your service. some maintenance activities might require temporary changes to your service behaviour or user messaging to minimise impact on user experience.\n\n security considerations for production\n\nproduction deployment requires implementing security measures that go beyond the basic integration requirements. these measures protect both your service and your users from various security threats whilst ensuring compliance with relevant security standards.\n\nkey management in production:\nuse dedicated secret management systems that provide encryption at rest, detailed access logging, and integration with your existing security infrastructure. implement key rotation procedures that allow you to periodically update your cryptographic keys without service interruption. plan for emergency key replacement procedures in case of suspected key compromise.\n\nnetwork security:\nensure all communication with scotaccount uses current tls versions and cipher suites. configure your network infrastructure to prevent unauthorised access to systems that handle authentication tokens or user session information. implement appropriate firewall rules that restrict access to scotaccount apis to only the systems that require it.\n\naudit and compliance:\nmaintain audit logs that support your organisation's compliance requirements whilst protecting user privacy. ensure that authentication-related data handling complies with relevant data protection regulations and your organisation's data governance policies. regular review audit logs for unusual patterns that might indicate security issues or compliance concerns.\n\nunderstanding these production considerations helps ensure that your scotaccount integration operates reliably and securely when serving real users in a live environment. proper preparation for production deployment reduces the likelihood of issues after go-live and ensures that your service provides a positive user experience with scotaccount authentication.",
        summary: "quick start checklist\n\n phase 1: setup & registration\n\n- [ ] generate rsa 3072-bit or ec p-256 key pair using openssl\n- [ ] securely store private key in secrets manager (aws secrets manager, azure ke...",
        keywords: "quick start checklist phase 1: setup & registration phase 2: basic authentication phase 3: verified attributes phase 4: production deployment complete authentication flow summary step 1: discovery configuration step 2: start authentication step 3: user authenticates step 4: exchange code for tokens step 5: validate id token step 6: request verified attributes (optional) step 7: logout understanding scotaccount: a developer's perspective the value proposition for developers core concepts you need to understand why openid connect and oauth 2.0 matter architecture overview phase 1: setup & registration understanding what you need to prepare cryptographic key generation strategy scope planning and data requirements analysis registration information preparation phase 2: basic authentication implementation understanding the openid connect flow discovery and configuration management pkce implementation strategy state management for csrf protection authorization request construction token exchange and client authentication token validation and user identity extraction phase 3: verified attributes integration understanding attribute requests attribute verification levels and trust progressive consent and user experience attribute data structure and validation attribute storage and lifecycle management testing strategy & mock service usage understanding testing environments testing strategy progression mock service implementation guide production-like environment testing recommended testing approach quick reference essential endpoints scope reference and data mapping token lifetimes and usage patterns common error codes and resolution phase 4: production deployment understanding production environment differences production configuration checklist production endpoints monitoring and operational considerations support and incident response security considerations for production",
        sections: [{"heading":"","id":"","content":""},{"heading":"Quick Start Checklist","id":"quick-start-checklist","content":""},{"heading":"Phase 1: Setup & Registration","id":"phase-1-setup-registration","content":"- [ ] generate rsa 3072-bit or ec p-256 key pair using openssl\n- [ ] securely store private key in secrets manager (aws secrets manager, azure key vault, etc.)\n- [ ] determine required scopes based on your service needs\n- [ ] identify production ip addresses for allowlisting (if applicable)\n- [ ] define redirect and logout uris for your service\n- [ ] submit complete registration information to scotaccount team\n- [ ] receive clientid confirmation and test connectivity"},{"heading":"Phase 2: Basic Authentication","id":"phase-2-basic-authentication","content":"- [ ] implement discovery endpoint integration to retrieve current configuration\n- [ ] build pkce parameter generation for security\n- [ ] create authorization request builder with proper state management\n- [ ] implement callback handler with comprehensive state validation\n- [ ] build jwt client assertion creator using your private key\n- [ ] complete token exchange implementation with error handling\n- [ ] add robust id token validation and user identity extraction"},{"heading":"Phase 3: Verified Attributes","id":"phase-3-verified-attributes","content":"- [ ] determine which additional scopes your service requires\n- [ ] implement attribute request flow with user consent handling\n- [ ] build attribute response processor to parse verified claims\n- [ ] add comprehensive attribute data validation and storage"},{"heading":"Phase 4: Production Deployment","id":"phase-4-production-deployment","content":"- [ ] update configuration to use production endpoints\n- [ ] implement comprehensive monitoring and logging\n- [ ] add user-friendly error handling and messaging\n- [ ] complete security review and penetration testing\n\n---"},{"heading":"Complete Authentication Flow Summary","id":"complete-authentication-flow-summary","content":"this section provides a step-by-step walkthrough of the entire authentication process with actual urls and data exchanges."},{"heading":"Step 1: Discovery Configuration","id":"step-1-discovery-configuration","content":"response provides all endpoint urls and supported features."},{"heading":"Step 2: Start Authentication","id":"step-2-start-authentication","content":"your application generates:\n\n- code verifier: \n- code challenge: \n- state: \n- nonce: \n\nredirect user to:"},{"heading":"Step 3: User Authenticates","id":"step-3-user-authenticates","content":"user logs in at scotaccount and is redirected back:"},{"heading":"Step 4: Exchange Code for Tokens","id":"step-4-exchange-code-for-tokens","content":"create client assertion jwt:\n\nmake token request:\n\nreceive tokens:"},{"heading":"Step 5: Validate ID Token","id":"step-5-validate-id-token","content":"extract and validate claims from id token:"},{"heading":"Step 6: Request Verified Attributes (Optional)","id":"step-6-request-verified-attributes-optional","content":"if you need verified data, start new flow with additional scopes:\n\nafter getting new access token, request attributes:"},{"heading":"Step 7: Logout","id":"step-7-logout","content":"when user logs out:\n\n---"},{"heading":"Understanding ScotAccount: A Developer's Perspective","id":"understanding-scotaccount-a-developers-perspective","content":"scotaccount serves as scotland's centralised digital identity provider, offering government services a secure way to authenticate citizens and access verified personal information. think of it as a trusted intermediary that handles the complex work of identity verification so your service doesn't have to build these capabilities from scratch."},{"heading":"The Value Proposition for Developers","id":"the-value-proposition-for-developers","content":"rather than building your own authentication system with all the associated complexity of password management, identity verification, and security compliance, scotaccount provides several key benefits. users authenticate once with scotaccount and can then access multiple government services seamlessly. your service gains access to verified identity data that has been independently validated through rigorous processes. the system provides security by design through openid connect standards, protecting against common web vulnerabilities. additionally, you benefit from built-in compliance support with data protection and audit capabilities already implemented."},{"heading":"Core Concepts You Need to Understand","id":"core-concepts-you-need-to-understand","content":"the distinction between authentication and verified attributes is fundamental to understanding how scotaccount works. authentication proves that someone is a returning user by providing you with a persistent uuid that uniquely identifies them across all interactions. verified attributes go further, providing specific information about that person that has been independently verified through various means such as credit reference checks, document verification, or email confirmation processes.\n\nscotaccount uses token-based security rather than traditional password handling. instead of your service managing user credentials, scotaccount provides cryptographically signed tokens that prove user identity and permissions. this delegation model means your service redirects users to scotaccount for authentication, then receives cryptographic proof of successful authentication without ever handling user credentials directly."},{"heading":"Why OpenID Connect and OAuth 2.0 Matter","id":"why-openid-connect-and-oauth-20-matter","content":"openid connect builds upon oauth 2.0 to provide a standardised approach to identity and authorisation. oauth 2.0 handles the authorisation aspect, determining what a user is allowed to access, whilst openid connect adds the identity layer, proving who the user actually is. this separation of concerns allows for more flexible and secure implementations.\n\nthe protocols include sophisticated protection mechanisms against common attack vectors. cross-site request forgery protection through state parameters, authorization code interception protection through pkce, and replay attack protection through nonce values all work together to create a robust security framework.\n\n---"},{"heading":"Architecture Overview","id":"architecture-overview","content":"!scotaccount high-level architecture\n\nfigure: high-level architecture of scotaccount and its integration with core dis components.\n\nthis architecture diagram illustrates the complete integration pattern between your government service and scotaccount. the flow begins when a user visits your service and needs to authenticate. your web application redirects them to scotaccount's authentication service, which handles the actual credential verification process.\n\nonce authentication is complete, scotaccount redirects the user back to your service with an authorization code. your backend processes this code by exchanging it for tokens through scotaccount's token service. if your service needs verified attributes about the user, you can make additional requests to the attribute service using the access token you received.\n\nthe final steps involve storing or updating user information in your database, creating an appropriate session, and granting access to your service. throughout this process, tokens are cryptographically signed jwts that you validate using scotaccount's public keys, ensuring authenticity and integrity.\n\n---"},{"heading":"Phase 1: Setup & Registration","id":"phase-1-setup-registration","content":""},{"heading":"Understanding What You Need to Prepare","id":"understanding-what-you-need-to-prepare","content":"before you can integrate with scotaccount, you need to establish a secure, trusted relationship between your service and scotaccount's infrastructure. this involves several critical components that work together to ensure secure communication and proper authorization.\n\nthe foundation of this relationship is cryptographic key management. you'll generate a public-private key pair where you keep the private key absolutely secure within your systems and provide the public key to scotaccount during registration. scotaccount uses your public key to verify that api requests are genuinely coming from your service.\n\nnetwork configuration is equally important, particularly for production deployments. scotaccount implements ip allowlisting as a security measure, meaning only requests from pre-registered ip addresses will be accepted. you'll need to identify all the ip addresses that your service will use to communicate with scotaccount.\n\nservice endpoint configuration defines how scotaccount will interact with your service during authentication flows. the redirect uri is where scotaccount will send users after they complete authentication, whilst the logout uri defines where users go after terminating their session."},{"heading":"Cryptographic Key Generation Strategy","id":"cryptographic-key-generation-strategy","content":"the security of your entire scotaccount integration depends on proper cryptographic key management. should use elliptic curve keys\n\nelliptic curve keys have smaller key sizes and good performance characteristics. the p-256 curve provides security roughly equivalent to a 3072-bit rsa keys whilst requiring significantly less computational resources. this can be particularly beneficial for high-volume services or resource-constrained environments.\n\nregardless of which key type you choose, the critical security requirement is proper private key storage. your private key must never exist in plain text outside of your application's runtime memory. use dedicated secret management systems like aws secrets manager, azure key vault, or hashicorp vault. the key should be loaded into your application at runtime and never written to configuration files, environment variables, or any persistent storage."},{"heading":"Scope Planning and Data Requirements Analysis","id":"scope-planning-and-data-requirements-analysis","content":"understanding which scopes your service requires is fundamental to a successful integration. each scope represents a specific type of information or capability that scotaccount can provide, and requesting the right combination of scopes ensures your service gets the data it needs whilst maintaining user trust through appropriate consent requests.\n\nthe openid scope is mandatory for all integrations as it provides the basic authentication functionality and the persistent user identifier that allows you to recognise returning users. this uuid is immutable and provides a reliable way to link user sessions and data across multiple interactions.\n\nthe scotaccount.gpg45.medium scope provides verified identity information including the user's given name, family name, and date of birth. this information has been verified to gpg45 medium assurance level through a comprehensive process that includes checking identity documents and performing various verification checks. this scope is essential for services that need to verify users' legal identities.\n\nthe scotaccount.address scope provides a verified postal address that has been checked against credit reference records. this verification process confirms that the user has a genuine connection to the provided address through financial or residency records. this scope is particularly useful for services that need to verify where users live for eligibility or delivery purposes.\n\nthe scotaccount.email scope provides an email address that has been verified through an email confirmation loop during the user's scotaccount registration process. this ensures that the user actually controls the provided email address and can receive communications sent to it.\n\nthe scotaccount.mobile scope provides a mobile number that has been verified through an sms confirmation loop during the user's scotaccount registration process. this ensures that the user actually controls the provided mobile number and can receive communications sent to it.\n\nwhen planning your scope requirements, consider implementing progressive consent where you request additional scopes only when they become necessary for specific functionality rather than requesting everything upfront. this approach can improve user experience and conversion rates."},{"heading":"Registration Information Preparation","id":"registration-information-preparation","content":"the registration process requires comprehensive information about your service configuration. this information is used to configure scotaccount's systems to work with your specific deployment architecture and security requirements.\n\nyour service information should include a clear service name and description that will be shown to users during authentication and consent flows. users need to understand what service they're granting access to, so this information should be clear and recognisable.\n\nnetwork configuration for production deployments must include all ip addresses that will make requests to scotaccount's apis. this typically includes your web servers, application servers, and any background services that might need to validate tokens or refresh authentication state. if your infrastructure uses load balancers, proxy servers, or content delivery networks, you need to understand how these affect the source ip addresses that scotaccount will see.\n\nservice endpoint configuration requires careful planning of your redirect and logout uris. these urls must be accessible to users' browsers and must exactly match what you register with scotaccount. even small differences in url structure, query parameters, or trailing slashes will cause authentication failures.\n\nyour cryptographic configuration section should specify whether you're using rsa or elliptic curve keys, the key length, and provide the complete public key content including all formatting and line breaks.\n\nscope requirements should list all the scopes your service needs along with a clear justification for why each scope is necessary. this helps scotaccount understand your use case and ensures that you're requesting appropriate permissions for your service's functionality.\n\n---"},{"heading":"Phase 2: Basic Authentication Implementation","id":"phase-2-basic-authentication-implementation","content":""},{"heading":"Understanding the OpenID Connect Flow","id":"understanding-the-openid-connect-flow","content":"openid connect authentication represents a sophisticated approach to solving the fundamental challenge of proving user identity in web applications. the protocol addresses many security and usability problems inherent in traditional username-and-password authentication through its delegation model.\n\nwhen a user attempts to authenticate with your service via scotaccount, they're not providing their credentials directly to your application. instead, your application redirects them to scotaccount, where they authenticate using whatever methods scotaccount supports. once authentication is complete, scotaccount provides your application with cryptographic proof that the user has been authenticated, along with a persistent identifier that allows you to recognise that user in future interactions.\n\nthis delegation model provides several crucial benefits that make it superior to traditional authentication approaches. your application never handles user passwords or other sensitive authentication credentials, reducing your security liability and simplifying compliance requirements. users benefit from a consistent authentication experience across all government services that use scotaccount, and they only need to maintain one set of authentication credentials for accessing multiple services.\n\nthe authentication flow incorporates several sophisticated protection mechanisms against common web application attacks. understanding these mechanisms helps you appreciate why certain steps in the process are mandatory and why attempting to simplify or skip steps can introduce serious security vulnerabilities.\n\n!scotaccount detailed flow diagram\n\nfigure: illustration of authentication flow.\n\nthis comprehensive flow diagram illustrates every critical step in the openid connect authentication process as implemented by scotaccount. each step serves specific security purposes and contributes to the overall integrity of the authentication system.\n\nthe process begins when a user attempts to access a protected resource in your service. your service recognises that authentication is required and initiates the openid connect flow by generating the necessary security parameters. the pkce parameters protect against authorization code interception attacks, whilst the state and nonce parameters provide protection against csrf and replay attacks respectively.\n\nyour service then redirects the user to scotaccount with a carefully constructed authorization request that includes all necessary parameters. scotaccount handles the actual authentication process, which may involve multiple steps depending on the user's account status and the security requirements.\n\nonce authentication is complete, scotaccount redirects the user back to your service with an authorization code. your service validates the state parameter to ensure the response corresponds to a request it actually made, then creates a client assertion jwt to prove its identity to scotaccount.\n\nthe token exchange step involves your service sending the authorization code, client assertion, and pkce code verifier to scotaccount's token endpoint. scotaccount validates all these components before issuing tokens that your service can use.\n\nfinally, your service validates the received tokens, extracts the user's identifier, and creates an appropriate session to grant access to the protected resource."},{"heading":"Discovery and Configuration Management","id":"discovery-and-configuration-management","content":"before your application can authenticate users, it needs to understand scotaccount's current configuration and capabilities. this information is provided through the openid connect discovery mechanism, which returns a json document containing endpoint urls, supported authentication methods, and other configuration details.\n\ndiscovery endpoint url:\n\nexample discovery request:\n\nexample discovery response:\n\njwks endpoint for public keys:\n\nexample jwks response:\n\ndynamic configuration retrieval is essential because it allows your service to adapt to changes in scotaccount's infrastructure without requiring code updates. scotaccount may periodically update endpoint urls, rotate cryptographic keys, or modify supported authentication methods. by retrieving configuration dynamically, your service can handle these changes automatically.\n\nthe discovery endpoint provides several critical pieces of information that your application will use throughout the authentication process. the issuer field identifies scotaccount as the identity provider and must match the issuer claims in tokens that scotaccount issues. the authorizationendpoint is where you'll send users to begin the authentication process, whilst the tokenendpoint is where your application will exchange authorization codes for tokens.\n\nthe jwksuri provides access to the cryptographic keys that scotaccount uses to sign tokens. your application will use these keys to validate the authenticity and integrity of tokens it receives. the various supported fields indicate which authentication methods, token types, and cryptographic algorithms scotaccount supports, helping ensure compatibility between your implementation and scotaccount's capabilities.\n\nimplementing robust configuration management involves caching the discovery response to improve performance whilst ensuring that your application picks up configuration changes within a reasonable timeframe. error handling should include fallback to cached configuration if the discovery endpoint is temporarily unavailable, helping maintain service availability during network issues or scotaccount maintenance periods."},{"heading":"PKCE Implementation Strategy","id":"pkce-implementation-strategy","content":"pkce (proof key for code exchange) is a critical security enhancement that protects the authorization code flow against interception attacks. understanding how pkce works and implementing it correctly is essential for maintaining the security of your scotaccount integration.\n\npkce addresses a specific vulnerability in the oauth 2.0 authorization code flow where an attacker might intercept the authorization code during the redirect back to your application. in traditional oauth 2.0, this authorization code could then be exchanged for tokens by anyone who possesses it.\n\npkce solves this problem by introducing a cryptographic challenge-response mechanism. your application generates a random code verifier, calculates a corresponding code challenge using sha256 hashing, and includes the code challenge in the initial authorization request. the authorization code that scotaccount returns is cryptographically bound to this code challenge.\n\nwhen your application exchanges the authorization code for tokens, it must provide the original code verifier. scotaccount can then verify that the code verifier matches the code challenge from the original request, proving that the token exchange request is coming from the same application that initiated the authorization flow.\n\nthe security of pkce depends entirely on the unpredictability of the code verifier. the code verifier must be generated using a cryptographically secure random number generator and must have sufficient entropy to resist brute-force attacks. the code verifier should be between 43 and 128 characters long and use the base64url character set.\n\nthe code challenge is calculated by taking the sha256 hash of the code verifier and encoding it using base64url encoding. this one-way transformation ensures that even if an attacker intercepts the code challenge, they cannot derive the original code verifier."},{"heading":"State Management for CSRF Protection","id":"state-management-for-csrf-protection","content":"the state parameter provides protection against cross-site request forgery attacks by ensuring that authorization responses correspond to requests that your application actually initiated. implementing state management correctly is crucial for maintaining the security of the authentication flow.\n\ncsrf attacks occur when an attacker tricks a user into performing actions they didn't intend by exploiting their existing authenticated sessions. in the context of openid connect, this could involve an attacker initiating an authentication flow and then tricking a victim into completing it, potentially allowing the attacker to gain access to the victim's account.\n\nthe state parameter prevents this attack by creating a unique, unpredictable value for each authentication request. your application generates this value and includes it in the authorization request. scotaccount returns the same state value in the authorization response, allowing your application to verify that the response corresponds to a request it actually made.\n\nproper state management involves generating cryptographically secure random state values that cannot be predicted by attackers. each state value should be single-use and have a limited lifetime to prevent replay attacks. your application should store the state value securely during the authentication flow and validate it when processing the authorization response.\n\nthe state validation step must occur before any other processing of the authorization response. if the state value doesn't match what your application originally generated, the entire response should be rejected as potentially malicious."},{"heading":"Authorization Request Construction","id":"authorization-request-construction","content":"the authorization request is the first step in the authentication flow where your application redirects the user to scotaccount for authentication. constructing this request correctly is crucial for both security and functionality.\n\nauthorization endpoint url:\n\ncomplete authorization request example:\n\neach parameter in the authorization request serves a specific purpose:\n\n- clientid: your unique identifier assigned during registration (e.g., )\n- redirecturi: where scotaccount sends users after authentication. must exactly match your registered uri\n- responsetype: always  for the authorization code flow\n- scope: space-separated list of requested permissions.  is mandatory\n- state: random value for csrf protection (you generate this)\n- nonce: random value for replay protection (you generate this)\n- codechallenge: sha256 hash of your code verifier, base64url encoded\n- codechallengemethod: always  for sha256\n\nexample with additional scopes:\n\nwhat happens next:\n\n1. user is redirected to scotaccount's login page\n2. user authenticates and grants consent\n3. scotaccount redirects back to your redirecturi with:"},{"heading":"Token Exchange and Client Authentication","id":"token-exchange-and-client-authentication","content":"the token exchange step is where your application proves its identity to scotaccount and exchanges the authorization code for usable tokens. this critical step requires your service to create a special jwt called a \"client assertion\" that acts like a digital signature, proving you are who you claim to be.\n\ntoken endpoint url:\n\nstep 1: create your client assertion jwt\n\nyour service creates a jwt with these claims:\n\nthis jwt is signed with your private key, resulting in something like:\n\nstep 2: make the token exchange request\n\nrequest parameters explained:\n\n- granttype: always \n- code: the authorization code from the callback\n- redirecturi: must match exactly what you used in the authorization request\n- clientassertiontype: always this exact urn value\n- clientassertion: your signed jwt proving your identity\n- codeverifier: the original pkce verifier you generated\n\nstep 3: receive tokens\n\nsuccess response:\n\nerror response example:\n\nthe key security aspects of this exchange:\n\n- your private key never leaves your system\n- the client assertion proves only you could have made this request\n- the code verifier proves you initiated the original flow\n- all parameters are validated together for maximum security"},{"heading":"Token Validation and User Identity Extraction","id":"token-validation-and-user-identity-extraction","content":"once your application receives tokens from scotaccount, it must validate them thoroughly before trusting their contents. token validation is a critical security step that ensures the tokens are authentic, haven't been tampered with, and are intended for your application.\n\njson web tokens used by scotaccount consist of three parts separated by dots: the header, payload, and signature. understanding this structure through a concrete example helps clarify what you're validating and why each step matters.\n\nexample id token (encoded):\n\nthis encoded token contains three base64url-encoded sections separated by dots. let's examine what's inside by decoding each section:\n\nheader (decoded):\n\nthe header tells us that this token is signed using rs256 (rsa with sha-256) and identifies which key was used to sign it through the kid (key id) field. your application will use this kid to look up the correct public key from scotaccount's jwks endpoint.\n\npayload (decoded):\n\nthe payload contains the actual claims about the authentication event. each field serves a specific purpose in the validation process:\n\n- sub (subject): this is the persistent user identifier (uuid) that uniquely identifies the user across all scotaccount services. this is the primary piece of information you'll extract and store.\n- aud (audience): your client id, confirming this token was issued specifically for your application.\n- iss (issuer): scotaccount's identifier, which must match the issuer from the discovery document.\n- exp (expiration): unix timestamp indicating when this token expires (15 minutes after issuance).\n- iat (issued at): unix timestamp of when the token was created.\n- nonce: the random value you provided in the authorization request, used to prevent replay attacks.\n- jti (jwt id): a unique identifier for this specific token.\n- sid (session id): scotaccount's session identifier, used for session management and logout.\n\nsignature:\nthe third part is the cryptographic signature that proves the token hasn't been tampered with and was genuinely issued by scotaccount. this signature is created using scotaccount's private key and can be verified using their public key.\n\nproper jwt validation involves several distinct steps, each of which protects against different types of attacks. signature verification ensures the token hasn't been tampered with and was indeed issued by scotaccount. this involves retrieving scotaccount's current public keys from the jwks endpoint and using them to verify the token's cryptographic signature.\n\nthe validation process involves several critical steps that must be performed in the correct order to ensure security. first, your service parses the jwt to extract the header and payload sections. using the key identifier from the header, you retrieve the appropriate public key from scotaccount's jwks endpoint. this key is then used to verify the cryptographic signature, ensuring the token hasn't been tampered with and was genuinely issued by scotaccount.\n\nafter signature verification, you must validate each claim in the token. the expiration time must be checked to ensure the token is still valid. the issuer must match scotaccount's identifier exactly as provided in the discovery document. the audience must be your client id, confirming this token was issued specifically for your service. the nonce must match the value your service provided in the original authorization request, preventing replay attacks.\n\nsuccessful validation confirms that the token is authentic, current, and intended for your service. the subject claim then provides the persistent user identifier that your service uses to recognise this user in all future interactions. this uuid remains constant for each user across all their sessions and interactions with your service.\n\nopenid connect specific validation includes verifying the nonce claim to prevent replay attacks. the nonce value in the token must match the nonce value your application included in the original authorization request. additionally, the subject claim provides the persistent user identifier that your application will use to recognise the user in future interactions.\n\nonce validation is complete, you can extract the user's persistent identifier from the sub claim and use it to establish or update the user's session within your application. this uuid uniquely and persistently identifies the user across all interactions with scotaccount-integrated services and serves as the foundation for user identity management in your service.\n\n---"},{"heading":"Phase 3: Verified Attributes Integration","id":"phase-3-verified-attributes-integration","content":""},{"heading":"Understanding Attribute Requests","id":"understanding-attribute-requests","content":"when your service needs verified information about users beyond their basic identity, you request additional scopes in the authentication flow. scotaccount will then guide users through appropriate consent screens and return verified data that has been independently validated through various verification processes.\n\nthe key principle behind verified attributes is user consent and data minimisation. users must be present and actively consent to sharing each type of verified information. scotaccount cannot provide verified attributes through background api calls or long-lived tokens - the user must be actively involved in the process each time new attributes are requested.\n\nthis consent-based approach serves both privacy and security purposes. users maintain control over what information they share with each service, and services are encouraged to request only the data they actually need. the verification processes that scotaccount uses to validate attributes are rigorous and involve multiple independent checks to ensure accuracy.\n\nthis flow diagram illustrates the complete process for requesting and receiving verified attributes from scotaccount. the process begins when a user attempts to access functionality that requires verified information beyond basic authentication.\n\nyour service first checks whether the user already has the required attributes stored locally. if the necessary verified information is already available, your service can proceed immediately without requiring additional authentication or consent steps.\n\nif additional attributes are needed, your service initiates a new authentication flow that includes the additional scopes for the required attributes. this triggers scotaccount's consent process, where users are clearly informed about what information is being requested and why.\n\nupon user consent, scotaccount provides an authorization code that your service exchanges for tokens, including an access token specifically scoped for the requested attributes. this access token is then used to make a request to scotaccount's attribute service, which returns the verified information in the form of a signed jwt.\n\nthe attribute jwt contains not only the verified claims but also detailed verification metadata that describes how each piece of information was verified and what level of assurance it carries. your service validates this jwt using the same cryptographic verification process used for id tokens."},{"heading":"Attribute Verification Levels and Trust","id":"attribute-verification-levels-and-trust","content":"understanding the different verification methods and assurance levels for each type of attribute helps you make informed decisions about which attributes to request and how to use the returned information appropriately.\n\ngpg45 medium identity verification represents a substantial level of assurance about a user's legal identity. this process involves checking official identity documents, performing various database checks, and applying sophisticated fraud detection techniques. when you receive identity information with gpg45 medium verification, you can have high confidence that it represents the user's actual legal identity as it appears on official documentation.\n\naddress verification through credit reference agencies provides strong assurance that the user has a genuine connection to the provided address. this verification process checks the address against multiple credit reference databases to confirm that the user has had a financial or legal connection to that address. while this doesn't necessarily mean they currently live there, it does provide significant assurance about the legitimacy of the address information.\n\nemail verification through confirmation loops provides assurance that the user controls the provided email address at the time of verification. this process involves sending a confirmation email with a unique link or code that the user must access to complete the verification. while simpler than other verification methods, this still provides valuable assurance for services that need to communicate with users via email.\n\neach verified attribute includes metadata that describes the verification process used, the confidence level achieved, and the timestamp of when the verification was performed. this metadata allows your service to make informed decisions about how to use the verified information and what level of trust to place in it."},{"heading":"Progressive Consent and User Experience","id":"progressive-consent-and-user-experience","content":"implementing verified attributes effectively requires careful consideration of the user experience and the timing of attribute requests. progressive consent, where you request additional attributes only when they become necessary for specific functionality, generally provides a better user experience than requesting all possible attributes upfront.\n\ncritical design consideration: extended gpg45 verification processes\n\nthe gpg45 medium identity verification process duration is entirely guided by the user's ability to complete the required steps. users may take days, weeks, or even longer to provide necessary documents and complete verification steps. this creates specific challenges that services must design for:\n\nhow scotaccount handles extended verification:\n\n1. user initiates verification: user begins gpg45 medium verification through your service's request\n2. scotaccount saves progress: scotaccount maintains the user's progress through verification steps\n3. time passes: the user may take any amount of time to complete verification steps\n4. sessions expire: your service session, scotaccount session, and all tokens will have expired\n5. user returns and logs in: when the user authenticates with scotaccount again, scotaccount automatically returns them to their saved point in the verification journey\n6. service perspective: your service initiated an authentication flow but never received a callback\n\nfrom your service's perspective, this appears as an abandoned authentication flow. however, scotaccount is maintaining the user's verification progress and will continue the process when they return.\n\ncross-browser and cross-device challenges:\n\nusers may start verification on one device/browser and complete it on another. this creates additional complexity:\n\n- state parameters won't match: the state parameter your service generated on the original browser won't exist in the new browser session\n- local session data is lost: any data stored in the original browser session isn't accessible\n- pkce parameters are missing: the code verifier stored in the original session is not available\n\nrecommended patterns for handling extended verification:\n\n1. track verification initiation\nrecord when users start verification processes so you can provide appropriate messaging when they return:\n\n- store the user id and timestamp when verification is initiated\n- track which scopes were requested\n- save any context about what the user was trying to accomplish\n\n2. design for stateless returns\nsince users may return on different devices, avoid relying on session state:\n\n- don't depend on the original state parameter being available\n- store important context server-side linked to the user id\n- be prepared to handle authentication callbacks without matching state parameters\n\n3. implement intelligent return handling\nwhen users authenticate without completing a previous flow:\n\n- check if they have previously initiated verification\n- provide clear messaging about continuing their verification\n- offer options to check status or proceed with limited functionality\n\n4. clear communication patterns\n\n- before starting: \"identity verification can take as long as you need. you can return anytime to continue where you left off.\"\n- when returning: \"welcome back! your identity verification is in progress. would you like to continue verifying your identity or proceed with limited access?\"\n- status checking: \"you started identity verification on [date]. continue verification to unlock full access.\"\n\n5. handle missing state gracefully\nwhen receiving callbacks without matching state:\n\n- log the event for security monitoring\n- check if the user has pending verification requests\n- provide appropriate options rather than showing errors\n\nexample user journeys:\n\nscenario 1: same device return\n\n- day 1: user starts application on laptop → begins verification\n- day 3: user returns on same laptop → scotaccount continues verification\n- day 4: user completes verification → your service receives verified attributes\n\nscenario 2: cross-device journey\n\n- day 1: user starts on mobile phone → begins verification\n- day 2: user continues on desktop computer → scotaccount recognises them and continues\n- day 5: user completes on tablet → your service receives callback on different device\n\nimportant considerations:\n\n- the verification duration is entirely user-controlled\n- scotaccount handles all progress saving and continuation\n- your service must handle callbacks that arrive days/weeks after initiation\n- cross-device flows mean you cannot rely on session state\n- design your user experience to accommodate these realities\n\nconsider a typical government service scenario where users might initially need only basic authentication to access general information, but later require identity verification to submit applications or access personalised services. by implementing progressive consent, you can allow users to access the general functionality immediately whilst requesting additional verified attributes only when they're actually needed.\n\nthis approach has several benefits for both user experience and conversion rates. users are more likely to grant consent for data sharing when they understand the specific purpose for which the information will be used. requesting attributes in context, when their necessity is clear, builds trust and reduces the likelihood of users abandoning the authentication process.\n\nhowever, progressive consent also requires careful implementation to avoid creating frustrating user experiences. your service should clearly communicate when additional verification will be required and provide smooth transitions between different levels of access."},{"heading":"Attribute Data Structure and Validation","id":"attribute-data-structure-and-validation","content":"verified attributes are returned in a structured json format within a signed jwt that includes both the actual attribute data and comprehensive verification metadata. understanding this structure is essential for properly extracting and validating the information your service receives.\n\nattributes endpoint url:\n\nattribute request example:\n\nimportant: the dis-client-assertion header contains a new client assertion jwt with the audience set to the attributes endpoint url.\n\nattribute response example:\n\ndecoded claims token structure:\n\nkey points about attribute responses:\n\n1. partial success is possible: if you request multiple scopes, scotaccount returns as many as it can verify. you might receive 0 to n attributes back.\n\n2. verification metadata: each attribute includes detailed verification information:\n\n   - : whether verification succeeded, had warnings, or failed\n   - : the standards framework used (typically \"uktfida\")\n   - : the assurance level achieved\n   - : how the data was verified\n   - : when verification occurred\n   - : who performed the verification\n\n3. error responses:\n   - : user has no verified attributes\n   - : invalid access token or client assertion\n   - : token doesn't have required scopes\n\nthe verified claims array contains one or more attribute objects, each corresponding to a scope that was requested and successfully provided. each attribute object includes the scope identifier, the actual claims data, and detailed verification information.\n\nwhen processing attribute data, your service should validate not only the cryptographic signature of the jwt but also examine the verification metadata to ensure that the attributes meet your specific requirements for assurance level and recency. different use cases may require different levels of verification, and the metadata provides the information needed to make these determinations."},{"heading":"Attribute Storage and Lifecycle Management","id":"attribute-storage-and-lifecycle-management","content":"once your service receives verified attributes, you need to consider how to store and manage this information throughout its lifecycle. verified attributes represent sensitive personal information that requires appropriate protection and management practices.\n\nconsider implementing appropriate data retention policies based on your service's specific requirements and legal obligations. some verified attributes may remain valid for extended periods, whilst others may require periodic re-verification. the verification metadata can help inform these decisions by providing information about when attributes were last verified.\n\nimplement secure storage practices that protect verified attributes both at rest and in transit. this includes using appropriate encryption, access controls, and audit logging to ensure that verified information is only accessed by authorised personnel for legitimate purposes.\n\nconsider the relationship between scotaccount's verification and your service's ongoing data management needs. while scotaccount provides initial verification of attributes, your service may need to implement additional validation or updating processes based on its specific requirements and use patterns.\n\nplan for scenarios where users may need to update their verified information or where verification status may change over time. your service should be able to handle requests for re-verification and should provide clear guidance to users about how to update their information when necessary.\n\n---"},{"heading":"Testing Strategy & Mock Service Usage","id":"testing-strategy-mock-service-usage","content":""},{"heading":"Understanding Testing Environments","id":"understanding-testing-environments","content":"scotaccount provides a comprehensive integration/sandpit environment that contains two distinct deployments to support different phases of your integration testing. understanding the purpose and capabilities of each deployment helps you plan an effective testing strategy that builds confidence in your integration before production deployment.\n\nmock service deployment\n\nthe mock service is a completely isolated test application designed to allow you to test the functionality and interactions of the scotaccount service without the complexity of full data verification or live data management. this service enables rapid development and testing cycles by providing predictable responses for all the standard oidc flows.\n\nmock service url:\n\nthe mock service's key benefits include:\n\n- no need to create or manage test user accounts\n- predictable responses for testing different code paths\n- ability to exercise all authentication and attribute flows\n- fast response times for automated testing\n- detailed documentation of limitations and behaviour at the service url\n\nthe mock service is ideal for:\n\n- initial development of your integration\n- automated testing in ci/cd pipelines\n- testing error handling and edge cases\n- demonstrating journey completeness\n- rapid iteration during development\n\nproduction-like environment\n\nthe second deployment is a fully functional, production-like environment that provides a representative experience of the live scotaccount service. this environment uses the same infrastructure, protocols, and security measures as production, giving you high confidence that integrations tested here will work correctly when you go live.\n\nthe production-like environment provides:\n\n- full oidc protocol implementation\n- real authentication flows with test accounts\n- complete security measures including ip allowlisting\n- actual consent and verification user interfaces\n- the same data structures and response formats as production\n\nkey limitation to note:\n\n- identity verification always returns successful/verified status\n- this makes it difficult to test failed verification scenarios\n- plan your testing accordingly to work around this limitation"},{"heading":"Testing Strategy Progression","id":"testing-strategy-progression","content":"an effective testing strategy progresses through both deployments in a structured manner, building confidence at each stage before moving to the next. think of this as climbing a ladder where each rung provides the foundation for safely reaching the next level.\n\nunderstanding each testing phase:\n\nphase 1: development environment - this is where you build your foundation. the mock service acts as your safe practice space where you can make mistakes without consequences. your unit tests verify individual components work correctly, while integration tests ensure these components play nicely together. the mock service responds instantly and predictably, allowing you to iterate quickly and build comprehensive test coverage.\n\nphase 2: integration validation - here you prove your integration works with the real scotaccount protocols. the production-like environment provides authentic oidc flows, actual user interfaces, and full security measures. you'll run end-to-end tests that mirror real user journeys, specific user journey tests for different scenarios, and security tests to validate your implementation. remember that identity verification always succeeds here, so plan your error handling based on specifications rather than test results.\n\nphase 3: production deployment - this is where your integration meets real users. smoke tests verify basic functionality immediately after deployment, while continuous monitoring watches for issues that only appear under real-world conditions. here you'll encounter actual verification outcomes, complete security controls, and the full complexity of production traffic.\n\nthe downward flow between phases represents increasing realism and decreasing flexibility. you cannot skip phases because each one validates different aspects of your integration. starting in production would be like learning to swim by jumping into the ocean - theoretically possible but unnecessarily risky."},{"heading":"Mock Service Implementation Guide","id":"mock-service-implementation-guide","content":"the mock service simulates all scotaccount endpoints and responses, allowing you to develop and test your integration without managing test data. think of it as a practice environment where you can make mistakes safely and learn how the service behaves. visit the mock service url for comprehensive documentation about its capabilities and limitations.\n\nusing the mock service effectively:\n\nthe beauty of the mock service lies in its simplicity. you don't need to register your client or provide ip addresses, which means you can start testing immediately. this rapid feedback loop is invaluable during initial development when you're still figuring out how all the pieces fit together.\n\nthe mock service provides predictable responses, which might seem artificial but serves an important purpose. when you're building your integration, you need to know that a specific request will always produce a specific response. this predictability allows you to build robust automated tests that won't fail due to external factors like network issues or data changes.\n\nunderstanding mock service boundaries:\n\nwhile the mock service is excellent for functional testing, it deliberately relaxes some security validations. for instance, it may not fully validate client assertion signatures or enforce strict parameter checking. this isn't a limitation but rather a feature that allows you to focus on getting the integration flow correct before worrying about every security detail.\n\nexample mock service endpoints follow the same pattern as production:\n\n- discovery: \n- authorization, token, and other endpoints: check the discovery response for exact urls\n\nthe mock service documentation (available at the service url) provides detailed information about which validations are relaxed and how responses differ from production behaviour. this transparency helps you understand exactly what you're testing and what you'll need to validate later in the production-like environment."},{"heading":"Production-Like Environment Testing","id":"production-like-environment-testing","content":"once your integration works correctly with the mock service, you're ready for the production-like environment. this transition is like moving from a flight simulator to an actual aircraft with an instructor - everything is real except for certain safety constraints.\n\nkey testing areas and what makes them important:\n\nthe production-like environment forces you to handle real-world complexity. your client assertions must be properly signed, your pkce parameters must be correctly generated, and your state management must be bulletproof. this is where you discover if your error handling can cope with actual scotaccount responses rather than simulated ones.\n\ntesting the consent flows with real ui is particularly valuable because it reveals user experience issues that the mock service cannot simulate. you'll see exactly how long each step takes, where users might get confused, and how your application needs to handle users who take unexpected paths through the authentication process.\n\nworking around the verification limitation:\n\nthe fact that gpg45 verification always succeeds in this environment is a significant limitation, but there are strategies to work around it. design your error handling based on the technical specification rather than what you can test. use defensive programming principles - assume that verification can fail and build your system to handle that gracefully, even if you can't test it directly.\n\nconsider creating a \"verification failed\" simulation in your own code during testing. you can temporarily modify your attribute parsing logic to treat successful verifications as failures, allowing you to test your error handling paths. just remember to remove this simulation before moving to production."},{"heading":"Recommended Testing Approach","id":"recommended-testing-approach","content":"starting with the mock service allows you to build momentum quickly. you can create a comprehensive test suite that exercises every path through your integration, giving you a safety net for future changes. focus on getting the happy paths working first, then systematically add error handling for each type of failure the specification describes.\n\nwhen you move to the production-like environment, approach it with fresh eyes. run through your test scenarios manually first to get a feel for the real system. pay attention to timing - how long do redirects take? how quickly do tokens expire? these real-world characteristics will inform how you design your user experience.\n\ndocument any scenarios you cannot test fully, particularly around verification failures. create a plan for monitoring these scenarios in production so you can respond quickly if issues arise. remember that the first time some error conditions occur will be in production, so comprehensive logging and alerting become your safety net.\n\nthis methodical progression from mock to production-like to production ensures that when you go live, you've tested everything that can be tested and have plans in place for everything that cannot.\n\n---\n\n---"},{"heading":"Quick Reference","id":"quick-reference","content":""},{"heading":"Essential Endpoints","id":"essential-endpoints","content":"the scotaccount service provides different endpoints for different environments, each serving specific purposes in your integration journey. understanding which endpoints to use in which circumstances is crucial for successful integration.\n\nintegration environment: the integration environment uses endpoints under the authz.integration.scotaccount.service.gov.scot domain and provides a complete scotaccount implementation with test data. this environment is perfect for development, testing, and final validation before production deployment. the discovery endpoint provides current configuration information including all other endpoint urls.\n\nproduction environment: the production environment uses endpoints under the authz.scotaccount.service.gov.scot domain and provides the live scotaccount service with real user data and full security controls. this environment requires ip allowlisting and uses production-grade security measures.\n\nmock environment: the mock environment uses endpoints under the mock-dis.main.integration.scotaccount.service.gov.scot domain and provides simulated responses for development and automated testing. this environment doesn't require real authentication and can simulate various success and failure scenarios."},{"heading":"Scope Reference and Data Mapping","id":"scope-reference-and-data-mapping","content":"understanding exactly what data each scope provides helps you request appropriate permissions and handle the returned information correctly in your service.\n\nopenid scope: this mandatory scope provides basic authentication functionality and returns a persistent user identifier in the sub claim of the id token. this uuid uniquely identifies the user across all scotaccount-integrated services and never changes for a given user. the authentication process verifies the user's identity to gpg45 medium assurance level.\n\nscotaccount.gpg45.medium scope: this scope provides verified identity information including the user's given name, family name, and date of birth as they appear on official identity documents. the verification process involves checking identity documents and performing various database checks to achieve gpg45 medium assurance level.\n\nscotaccount.address scope: this scope provides a verified postal address that has been checked against credit reference records. the returned address includes detailed components such as building numbers, street names, locality information, and postal codes, along with verification metadata describing the validation process.\n\nscotaccount.email scope: this scope provides an email address that has been verified through an email confirmation loop during the user's scotaccount registration. the verification process confirms that the user controls the provided email address and can receive messages sent to it."},{"heading":"Token Lifetimes and Usage Patterns","id":"token-lifetimes-and-usage-patterns","content":"understanding token lifetimes helps you implement appropriate caching, refresh, and error handling strategies in your integration.\n\nauthorization code: authorization codes are single-use tokens with a 10-minute lifetime that must be exchanged for usable tokens immediately after being received. these codes cannot be stored or reused and should be processed as soon as they're received from the authorization callback.\n\naccess token: access tokens have a 15-minute lifetime and are used for making api requests to scotaccount's attribute service. these tokens are scoped to specific attributes and cannot be used beyond their intended scope or lifetime.\n\nid token: id tokens have a 15-minute lifetime and contain user identity claims that have been cryptographically signed by scotaccount. these tokens should be validated immediately upon receipt and the claims extracted for use in your application.\n\nrefresh token: refresh tokens have a 15-minute lifetime and provide limited token refresh capabilities. the refresh token mechanism in scotaccount is primarily designed for extending access to attribute apis rather than long-term session management.\n\nsession: service session duration is 1 hour."},{"heading":"Common Error Codes and Resolution","id":"common-error-codes-and-resolution","content":"understanding common error scenarios and their resolutions helps you implement effective error handling and provide appropriate user guidance.\n\nauthorization endpoint errors (302 redirect):\n\ncommon authorization errors:\n\n- : missing or invalid parameters (check scopes, redirecturi)\n- : user cancelled or denied consent\n- : requested scope not supported or not granted to your client\n- : scotaccount internal error\n\ntoken endpoint errors (400/401 json response):\n\ncommon token errors:\n\n- : your clientid is not recognised or client assertion validation failed\n- : authorization code expired, already used, or doesn't match your client\n- : missing required parameters or malformed request\n- : your client isn't authorised for the requested grant type\n\nattribute endpoint errors:\n\n- : access token expired or client assertion invalid\n- : token lacks required scopes for requested attributes\n- : no verified attributes available for the user\n- : scotaccount service issue\n\nresolution guide:\n\ninvalidclient errors typically indicate that your clientid is not recognised by scotaccount or that your client authentication is failing. verify that:\n\n- your clientid matches exactly what was registered\n- your client assertion jwt is properly signed with your registered private key\n- the audience claim in your client assertion matches the endpoint url exactly\n- your client assertion hasn't expired (check the 6-month expiry)\n\ninvalidrequest errors indicate that required parameters are missing or malformed in your requests. check that:\n\n- all mandatory parameters are present and properly formatted\n- redirect uri matches exactly (including trailing slashes)\n- scopes are space-separated and url-encoded\n- pkce parameters are properly generated and matched\n\naccessdenied errors occur when users deny consent for authentication or data sharing. handle these gracefully by:\n\n- providing clear explanation of why permissions are needed\n- offering alternative ways to use your service without full permissions\n- not repeatedly requesting the same permissions in a loop\n\ninvalidgrant errors typically indicate authorization code issues. ensure that:\n\n- codes are exchanged immediately (within 10 minutes)\n- each code is only used once\n- the redirecturi in token exchange matches the authorization request\n- the pkce verifier matches the original challenge\n\n---"},{"heading":"Phase 4: Production Deployment","id":"phase-4-production-deployment","content":""},{"heading":"Understanding Production Environment Differences","id":"understanding-production-environment-differences","content":"moving from development and testing to production involves several important changes that affect both security and operational considerations. the production environment implements stricter security controls and requires additional configuration that isn't necessary during development.\n\nthe most significant difference is the ip allowlisting requirement for production deployments. unlike the integration environment where any ip address can connect for testing purposes, production requires that you register all ip addresses that will communicate with scotaccount's apis. this security measure helps protect against unauthorised access and provides an additional audit trail for all api communications.\n\nproduction endpoints use different urls from the integration environment, and you'll need to update your configuration accordingly. your redirect uris must use https in production (localhost http uris are not permitted), and your logout uris must also be publicly accessible https endpoints."},{"heading":"Production Configuration Checklist","id":"production-configuration-checklist","content":"environment configuration updates:\n\n- [ ] update discovery endpoint to production url\n- [ ] update all redirect uris to use https production urls\n- [ ] update logout uri to production https endpoint\n- [ ] generate new cryptographic keys for production (never reuse development keys)\n- [ ] register production public key with scotaccount\n- [ ] provide complete list of production ip addresses for allowlisting\n\nsecurity implementation requirements:\n\n- [ ] store private keys in dedicated secret management systems\n- [ ] implement comprehensive logging for all authentication events\n- [ ] add monitoring for authentication success/failure rates\n- [ ] configure alerting for unusual authentication patterns\n- [ ] implement session timeout handling appropriate for your service\n- [ ] add comprehensive error handling with user-friendly messages\n\noperational readiness:\n\n- [ ] test complete authentication flows in production environment\n- [ ] verify all error scenarios handle gracefully\n- [ ] confirm monitoring and alerting systems are working\n- [ ] document support procedures for common user issues\n- [ ] establish communication channels with scotaccount support team\n- [ ] plan for handling service outages or maintenance windows"},{"heading":"Production Endpoints","id":"production-endpoints","content":"| service       | production endpoint                                                           |\n| ------------- | ----------------------------------------------------------------------------- |\n| discovery     |  |\n| authorization | retrieved from discovery (typically )                             |\n| token         | retrieved from discovery (typically )                                 |\n| jwks          | retrieved from discovery (typically )                             |\n| attributes    | retrieved from discovery (typically )                     |"},{"heading":"Monitoring and Operational Considerations","id":"monitoring-and-operational-considerations","content":"implementing comprehensive monitoring helps ensure reliable operation and quick identification of issues that might affect user experience. authentication services require specific monitoring approaches that track both technical metrics and user experience indicators.\n\ncritical metrics to monitor:\n\n- authentication success and failure rates over time\n- token validation errors and their frequency\n- discovery endpoint availability and response times\n- jwks endpoint accessibility and key rotation events\n- user session duration and timeout patterns\n- error rates by error type to identify common issues\n\nalerting strategy:\nconfigure alerts for metrics that indicate immediate problems requiring attention. authentication failure rates above normal baselines might indicate service issues or potential security concerns. discovery endpoint failures prevent new authentication flows from starting. jwks endpoint issues prevent token validation and can cause widespread authentication failures.\n\nuser experience monitoring:\ntrack user journey completion rates through authentication flows to identify points where users commonly abandon the process. monitor the time users spend on scotaccount authentication pages, as unusually long times might indicate usability issues or service performance problems.\n\nsecurity event logging:\nmaintain comprehensive logs of all authentication events for both operational and security purposes. log successful authentications with user identifiers and timestamps, failed authentication attempts with error details, and any unusual patterns that might indicate security issues. ensure logs include sufficient detail for troubleshooting whilst protecting sensitive user information."},{"heading":"Support and Incident Response","id":"support-and-incident-response","content":"establish clear procedures for handling authentication-related user issues and service incidents. users may experience authentication problems due to various factors including expired sessions, browser issues, or temporary service disruptions.\n\ncommon user issues and resolutions:\nauthentication failures often result from expired sessions, where users have remained on your service longer than scotaccount's session lifetime. implement clear messaging that explains when users need to re-authenticate and provides easy ways to restart the authentication process.\n\nbrowser compatibility issues can affect the authentication flow, particularly with older browsers or those with strict security settings. provide guidance for users about supported browsers and common browser configuration issues that might prevent successful authentication.\n\nservice incident response:\ndevelop procedures for handling scotaccount service outages or degraded performance. consider implementing fallback authentication methods for critical services, though these should be designed carefully to maintain security standards. establish communication procedures with the scotaccount operations team for reporting and coordinating resolution of service issues.\n\nplanned maintenance coordination:\nwork with the scotaccount team to understand planned maintenance schedules that might affect your service. some maintenance activities might require temporary changes to your service behaviour or user messaging to minimise impact on user experience."},{"heading":"Security Considerations for Production","id":"security-considerations-for-production","content":"production deployment requires implementing security measures that go beyond the basic integration requirements. these measures protect both your service and your users from various security threats whilst ensuring compliance with relevant security standards.\n\nkey management in production:\nuse dedicated secret management systems that provide encryption at rest, detailed access logging, and integration with your existing security infrastructure. implement key rotation procedures that allow you to periodically update your cryptographic keys without service interruption. plan for emergency key replacement procedures in case of suspected key compromise.\n\nnetwork security:\nensure all communication with scotaccount uses current tls versions and cipher suites. configure your network infrastructure to prevent unauthorised access to systems that handle authentication tokens or user session information. implement appropriate firewall rules that restrict access to scotaccount apis to only the systems that require it.\n\naudit and compliance:\nmaintain audit logs that support your organisation's compliance requirements whilst protecting user privacy. ensure that authentication-related data handling complies with relevant data protection regulations and your organisation's data governance policies. regular review audit logs for unusual patterns that might indicate security issues or compliance concerns.\n\nunderstanding these production considerations helps ensure that your scotaccount integration operates reliably and securely when serving real users in a live environment. proper preparation for production deployment reduces the likelihood of issues after go-live and ensures that your service provides a positive user experience with scotaccount authentication."}]
      },
      
      {
        title: "Token Validation Module",
        url: "/sg-identity-techdocs/scotaccount-token-validation-module/",
        content: "proper token validation is critical for security. this guide shows you how to validate id tokens and access tokens from scotaccount to ensure they're authentic and intended for your service.\n\n security overview\n\nscotaccount issues json web tokens (jwts) that must be validated before trusting their contents. this ensures tokens haven't been tampered with and were genuinely issued by scotaccount.\n\ncritical security warning: never trust token contents without proper validation. always verify signatures and claims to prevent security vulnerabilities.\n\n what you must validate\n\n1. token signature - verify the token was signed by scotaccount\n2. issuer claim - confirm the token was issued by scotaccount\n3. audience claim - ensure the token is intended for your service\n4. expiration - check the token hasn't expired\n5. nonce - prevent replay attacks (for id tokens)\n\n id token validation\n\nid tokens contain user identity information and must be validated immediately after receiving them from the token endpoint.\n\n id token structure\n\nexample id token payload (after validation):\n\nkey claims explained:\n\n-  - persistent user identifier (uuid that never changes)\n-  - your client id (ensures token is for your service)\n-  - scotaccount issuer (confirms who issued the token)\n-  - expiration time (unix timestamp)\n-  - issued at time (unix timestamp)\n-  - replay protection (must match your original nonce)\n-  - unique token id (prevents duplicate tokens)\n-  - session id (required for logout)\n\n complete validation implementation\n\n step 1: set up jwks client\n\n step 2: implement validation function\n\n step 3: additional security validations\n\n step 4: extract and store user information\n\n verified attributes validation\n\nverified attributes are provided by the attributes endpoint as a signed  jwt that includes a  array. validate the jwt and extract claims for the scopes you requested.\n\n identity (gpg45 medium) extraction (from claimstoken)\n\n address extraction (from claimstoken)\n\n access token usage\n\nuse the access token (15 minutes) to call  with a  whose audience is the attributes url.\n\n complete validation example\n\nhere's a complete example showing validation in an express.js application:\n\n error handling\n\n common validation errors\n\ninvalid signature:\n\nexpired token:\n\nwrong audience:\n\n security best practices\n\n1. always validate tokens before trusting their contents\n2. use the latest token after refresh operations\n3. log validation failures for security monitoring\n4. implement rate limiting on validation endpoints\n5. cache public keys but refresh periodically\n6. handle clock skew with appropriate tolerance\n7. validate all custom claims from verified attributes\n\n testing token validation\n\n unit test example\n\n production considerations\n\n performance optimisation\n\n- cache jwks keys with appropriate ttl\n- implement connection pooling for http requests\n- use asynchronous validation to avoid blocking\n- consider token validation libraries for your platform\n\n monitoring and alerts\n\n- track validation failures and investigate patterns\n- monitor token expiration rates to detect issues\n- alert on signature validation failures as potential attacks\n- log all validation events for audit purposes\n\n next steps\n\nvalidation implemented? review the architecture overview to understand the complete system design.\n\nneed implementation help? see the complete implementation guide for full integration patterns.\n\nsecurity questions? contact the scotaccount team for security review and production deployment guidance.",
        summary: "proper token validation is critical for security. this guide shows you how to validate id tokens and access tokens from scotaccount to ensure they're authentic and intended for your service.\n\n securit...",
        keywords: "security overview what you must validate id token validation id token structure complete validation implementation verified attributes validation identity (gpg45 medium) extraction (from claimstoken) address extraction (from claimstoken) access token usage complete validation example error handling common validation errors security best practices testing token validation unit test example production considerations performance optimisation monitoring and alerts next steps",
        sections: [{"heading":"","id":"","content":"proper token validation is critical for security. this guide shows you how to validate id tokens and access tokens from scotaccount to ensure they're authentic and intended for your service."},{"heading":"Security Overview","id":"security-overview","content":"scotaccount issues json web tokens (jwts) that must be validated before trusting their contents. this ensures tokens haven't been tampered with and were genuinely issued by scotaccount.\n\ncritical security warning: never trust token contents without proper validation. always verify signatures and claims to prevent security vulnerabilities."},{"heading":"What You Must Validate","id":"what-you-must-validate","content":"1. token signature - verify the token was signed by scotaccount\n2. issuer claim - confirm the token was issued by scotaccount\n3. audience claim - ensure the token is intended for your service\n4. expiration - check the token hasn't expired\n5. nonce - prevent replay attacks (for id tokens)"},{"heading":"ID Token Validation","id":"id-token-validation","content":"id tokens contain user identity information and must be validated immediately after receiving them from the token endpoint."},{"heading":"ID Token Structure","id":"id-token-structure","content":"example id token payload (after validation):\n\nkey claims explained:\n\n-  - persistent user identifier (uuid that never changes)\n-  - your client id (ensures token is for your service)\n-  - scotaccount issuer (confirms who issued the token)\n-  - expiration time (unix timestamp)\n-  - issued at time (unix timestamp)\n-  - replay protection (must match your original nonce)\n-  - unique token id (prevents duplicate tokens)\n-  - session id (required for logout)"},{"heading":"Complete Validation Implementation","id":"complete-validation-implementation","content":""},{"heading":"Step 1: Set Up JWKS Client","id":"step-1-set-up-jwks-client","content":""},{"heading":"Step 2: Implement Validation Function","id":"step-2-implement-validation-function","content":""},{"heading":"Step 3: Additional Security Validations","id":"step-3-additional-security-validations","content":""},{"heading":"Step 4: Extract and Store User Information","id":"step-4-extract-and-store-user-information","content":""},{"heading":"Verified Attributes Validation","id":"verified-attributes-validation","content":"verified attributes are provided by the attributes endpoint as a signed  jwt that includes a  array. validate the jwt and extract claims for the scopes you requested."},{"heading":"Identity (GPG45 Medium) extraction (from claimsToken)","id":"identity-gpg45-medium-extraction-from-claimstoken","content":""},{"heading":"Address extraction (from claimsToken)","id":"address-extraction-from-claimstoken","content":""},{"heading":"Access Token Usage","id":"access-token-usage","content":"use the access token (15 minutes) to call  with a  whose audience is the attributes url."},{"heading":"Complete Validation Example","id":"complete-validation-example","content":"here's a complete example showing validation in an express.js application:"},{"heading":"Error Handling","id":"error-handling","content":""},{"heading":"Common Validation Errors","id":"common-validation-errors","content":"invalid signature:\n\nexpired token:\n\nwrong audience:"},{"heading":"Security Best Practices","id":"security-best-practices","content":"1. always validate tokens before trusting their contents\n2. use the latest token after refresh operations\n3. log validation failures for security monitoring\n4. implement rate limiting on validation endpoints\n5. cache public keys but refresh periodically\n6. handle clock skew with appropriate tolerance\n7. validate all custom claims from verified attributes"},{"heading":"Testing Token Validation","id":"testing-token-validation","content":""},{"heading":"Unit Test Example","id":"unit-test-example","content":""},{"heading":"Production Considerations","id":"production-considerations","content":""},{"heading":"Performance Optimisation","id":"performance-optimisation","content":"- cache jwks keys with appropriate ttl\n- implement connection pooling for http requests\n- use asynchronous validation to avoid blocking\n- consider token validation libraries for your platform"},{"heading":"Monitoring and Alerts","id":"monitoring-and-alerts","content":"- track validation failures and investigate patterns\n- monitor token expiration rates to detect issues\n- alert on signature validation failures as potential attacks\n- log all validation events for audit purposes"},{"heading":"Next Steps","id":"next-steps","content":"validation implemented? review the architecture overview to understand the complete system design.\n\nneed implementation help? see the complete implementation guide for full integration patterns.\n\nsecurity questions? contact the scotaccount team for security review and production deployment guidance."}]
      },
      
      {
        title: "Integration Examples and Best Practices",
        url: "/sg-identity-techdocs/integration-examples/",
        content: "this page provides practical integration examples and best practices for scotaccount, helping you implement secure, robust code that you can tailor for your needs. these code elements are for example purposes only\n\n phase 1: setup & registration examples\n\n discovery endpoint integration\n\nalways retrieve current configuration dynamically:\n\nkey configuration values:\n\n-  - where to send authentication requests\n-  - where to exchange codes for tokens\n-  - public keys for token validation\n\n pkce implementation\n\ngenerate pkce parameters for security:\n\n phase 2: basic authentication examples\n\n authorization request builder\n\nbuild the authentication url:\n\n callback handler\n\nprocess the authentication response:\n\n jwt client assertion\n\ncreate signed jwt for token exchange:\n\n token exchange\n\nexchange authorization code for tokens:\n\n id token validation\n\nvalidate and extract user information:\n\n phase 3: verified attributes examples\n\n attribute request implementation\n\nrequest verified attributes using access token:\n\n attribute token validation\n\nvalidate and extract verified claims:\n\n phase 4: production deployment examples\n\n environment configuration\n\nupdate endpoints for production:\n\n monitoring and logging\n\nimplement comprehensive monitoring:\n\n error handling\n\nimplement user-friendly error handling:\n\n complete example implementation\n\nhere's a complete node.js/express example:\n\n example: complete authentication flow\n\nimplementing pkce (proof key for code exchange):\n\n- why: enhances security by preventing interception attacks\n- how: always implement pkce with the sha256 method as shown below\n\n example: token validation\n\nverifying id tokens:\n\n- why: ensures tokens are valid and not tampered with\n- how: always validate tokens as shown below\n\n example: secure session management\n\nstoring sessions securely:\n\n- why: protects user data and prevents unauthorised access\n- how: use encrypted, server-side session storage\n\n example: multi-environment configuration\n\nconfiguring for different environments:\n\n- why: ensures correct settings for development, integration, and production\n- how: use environment-specific configuration as shown below\n\n example: error handling\n\nhandling authentication errors:\n\n- why: improves user experience and simplifies debugging\n- how: implement detailed error handling for different scenarios\n\n example: monitoring and logging\n\ntracking authentication events:\n\n- why: enables auditing and monitoring of authentication flows\n- how: log events and metrics as shown below\n\n example: integration and security testing\n\ntesting authentication and security:\n\n- why: ensures your integration is robust and secure\n- how: use integration and security tests as shown below\n\n production readiness checklist\n\n- [ ] https enforcement in all environments\n- [ ] security headers implementation\n- [ ] rate limiting on authentication endpoints\n- [ ] cors configuration for allowed origins\n- [ ] csp headers for xss protection\n- [ ] secure cookie settings for session management\n- [ ] environment variable validation on startup\n- [ ] health check endpoints for monitoring\n- [ ] graceful shutdown handling\n- [ ] database connection pooling configuration\n\n- [ ] performance optimisations (e.g., jwt key caching, connection pooling, request timeouts)\n\n next steps\n\nready to integrate? use these examples and best practices to build a secure, robust scotaccount integration.\n\nneed more help? follow the complete implementation guide for comprehensive solutions.\n\nquestions about security? review the token validation module for detailed security guidance.",
        summary: "this page provides practical integration examples and best practices for scotaccount, helping you implement secure, robust code that you can tailor for your needs. these code elements are for example ...",
        keywords: "phase 1: setup & registration examples discovery endpoint integration pkce implementation phase 2: basic authentication examples authorization request builder callback handler jwt client assertion token exchange id token validation phase 3: verified attributes examples attribute request implementation attribute token validation phase 4: production deployment examples environment configuration monitoring and logging error handling complete example implementation example: complete authentication flow example: token validation example: secure session management example: multi-environment configuration example: error handling example: monitoring and logging example: integration and security testing production readiness checklist next steps",
        sections: [{"heading":"","id":"","content":"this page provides practical integration examples and best practices for scotaccount, helping you implement secure, robust code that you can tailor for your needs. these code elements are for example purposes only"},{"heading":"Phase 1: Setup & Registration Examples","id":"phase-1-setup-registration-examples","content":""},{"heading":"Discovery Endpoint Integration","id":"discovery-endpoint-integration","content":"always retrieve current configuration dynamically:\n\nkey configuration values:\n\n-  - where to send authentication requests\n-  - where to exchange codes for tokens\n-  - public keys for token validation"},{"heading":"PKCE Implementation","id":"pkce-implementation","content":"generate pkce parameters for security:"},{"heading":"Phase 2: Basic Authentication Examples","id":"phase-2-basic-authentication-examples","content":""},{"heading":"Authorization Request Builder","id":"authorization-request-builder","content":"build the authentication url:"},{"heading":"Callback Handler","id":"callback-handler","content":"process the authentication response:"},{"heading":"JWT Client Assertion","id":"jwt-client-assertion","content":"create signed jwt for token exchange:"},{"heading":"Token Exchange","id":"token-exchange","content":"exchange authorization code for tokens:"},{"heading":"ID Token Validation","id":"id-token-validation","content":"validate and extract user information:"},{"heading":"Phase 3: Verified Attributes Examples","id":"phase-3-verified-attributes-examples","content":""},{"heading":"Attribute Request Implementation","id":"attribute-request-implementation","content":"request verified attributes using access token:"},{"heading":"Attribute Token Validation","id":"attribute-token-validation","content":"validate and extract verified claims:"},{"heading":"Phase 4: Production Deployment Examples","id":"phase-4-production-deployment-examples","content":""},{"heading":"Environment Configuration","id":"environment-configuration","content":"update endpoints for production:"},{"heading":"Monitoring and Logging","id":"monitoring-and-logging","content":"implement comprehensive monitoring:"},{"heading":"Error Handling","id":"error-handling","content":"implement user-friendly error handling:"},{"heading":"Complete Example Implementation","id":"complete-example-implementation","content":"here's a complete node.js/express example:"},{"heading":"Example: Complete Authentication Flow","id":"example-complete-authentication-flow","content":"implementing pkce (proof key for code exchange):\n\n- why: enhances security by preventing interception attacks\n- how: always implement pkce with the sha256 method as shown below"},{"heading":"Example: Token Validation","id":"example-token-validation","content":"verifying id tokens:\n\n- why: ensures tokens are valid and not tampered with\n- how: always validate tokens as shown below"},{"heading":"Example: Secure Session Management","id":"example-secure-session-management","content":"storing sessions securely:\n\n- why: protects user data and prevents unauthorised access\n- how: use encrypted, server-side session storage"},{"heading":"Example: Multi-Environment Configuration","id":"example-multi-environment-configuration","content":"configuring for different environments:\n\n- why: ensures correct settings for development, integration, and production\n- how: use environment-specific configuration as shown below"},{"heading":"Example: Error Handling","id":"example-error-handling","content":"handling authentication errors:\n\n- why: improves user experience and simplifies debugging\n- how: implement detailed error handling for different scenarios"},{"heading":"Example: Monitoring and Logging","id":"example-monitoring-and-logging","content":"tracking authentication events:\n\n- why: enables auditing and monitoring of authentication flows\n- how: log events and metrics as shown below"},{"heading":"Example: Integration and Security Testing","id":"example-integration-and-security-testing","content":"testing authentication and security:\n\n- why: ensures your integration is robust and secure\n- how: use integration and security tests as shown below"},{"heading":"Production Readiness Checklist","id":"production-readiness-checklist","content":"- [ ] https enforcement in all environments\n- [ ] security headers implementation\n- [ ] rate limiting on authentication endpoints\n- [ ] cors configuration for allowed origins\n- [ ] csp headers for xss protection\n- [ ] secure cookie settings for session management\n- [ ] environment variable validation on startup\n- [ ] health check endpoints for monitoring\n- [ ] graceful shutdown handling\n- [ ] database connection pooling configuration\n\n- [ ] performance optimisations (e.g., jwt key caching, connection pooling, request timeouts)"},{"heading":"Next Steps","id":"next-steps","content":"ready to integrate? use these examples and best practices to build a secure, robust scotaccount integration.\n\nneed more help? follow the complete implementation guide for comprehensive solutions.\n\nquestions about security? review the token validation module for detailed security guidance."}]
      },
      
      {
        title: "ScotAccount Modular Structure",
        url: "/sg-identity-techdocs/scotaccount-modular-structure/",
        content: "scotaccount is built using a modular architecture that separates concerns and enables flexible integration patterns. this page explains the service organisation and how different modules work together.\n\n service modules overview\n\nscotaccount consists of several interconnected modules, each with specific responsibilities:\n\n core authentication module\n\n- primary responsibility: user authentication and session management\n- key features: openid connect authentication, jwt token issuance, session handling\n- integration point: all relying parties connect to this module for basic authentication\n\n identity verification module (verifyyouridentity)\n\n- primary responsibility: gpg45 medium assurance identity verification\n- key features: document scanning, biometric verification, pep/sanctions checks\n- integration point: invoked when verified identity attributes are required\n\n attribute storage module (mysafe)\n\n- primary responsibility: secure storage and management of verified user data\n- key features: encrypted data storage, consent management, attribute retrieval\n- integration point: provides verified attributes to relying parties\n\n consent management module\n\n- primary responsibility: user consent tracking and management\n- key features: granular consent controls, audit trails, user self-service\n- integration point: embedded in authentication flows requiring data sharing\n\n module integration patterns\n\n basic authentication pattern\n\n verified attributes pattern\n\n identity verification pattern\n\n module responsibilities\n\n what each module handles\n\nauthentication module:\n\n- user registration and login\n- openid connect protocol implementation\n- jwt token generation and validation\n- session lifecycle management\n- basic user profile data\n\nidentity verification module:\n\n- document capture and verification\n- biometric identity matching\n- external service integration (experian, etc.)\n- verification workflow management\n- cross-device verification support\n\nattribute storage module:\n\n- encrypted storage of verified data\n- consent tracking and enforcement\n- data retrieval for authorised requests\n- audit logging and compliance\n- data retention and deletion\n\nconsent management module:\n\n- user consent collection\n- granular permission management\n- consent withdrawal handling\n- audit trail maintenance\n- user preference management\n\n integration considerations\n\n modular integration benefits\n\nflexible implementation:\n\n- integrate only the modules you need\n- start with basic authentication, add verification later\n- independent module updates and maintenance\n\nscalable architecture:\n\n- modules can scale independently\n- load balancing per module\n- fault isolation between modules\n\nsecurity by design:\n\n- module-level security boundaries\n- least privilege access patterns\n- independent security auditing\n\n module dependencies\n\ncore dependencies:\n\n- authentication module: required for all integrations\n- consent management: required when requesting verified attributes\n- identity verification: optional, based on service requirements\n- attribute storage: required for verified attribute access\n\noptional dependencies:\n\n- address verification services\n- email verification services\n- additional external verification providers\n\n development approach\n\n modular development strategy\n\n1. start with authentication module\n\n   - implement basic openid connect integration\n   - establish user session management\n   - test authentication flows\n\n2. add consent management\n\n   - implement consent collection\n   - add granular permission controls\n   - test consent workflows\n\n3. integrate verification module\n\n   - add identity verification flows\n   - implement cross-device support\n   - test verification processes\n\n4. enable attribute storage\n   - access verified user data\n   - implement secure data handling\n   - test attribute retrieval\n\n module testing approach\n\nunit testing:\n\n- test each module independently\n- mock external module dependencies\n- validate module interfaces\n\nintegration testing:\n\n- test module communication\n- validate data flow between modules\n- test error handling across modules\n\nend-to-end testing:\n\n- test complete user journeys\n- validate cross-module functionality\n- test module fault tolerance\n\n next steps\n\nneed implementation guidance? start with the getting started guide to implement the authentication module first.\n\nplanning your architecture? review the architecture overview to understand how modules fit together.\n\nready for detailed implementation? see the complete implementation guide for comprehensive technical details.",
        summary: "scotaccount is built using a modular architecture that separates concerns and enables flexible integration patterns. this page explains the service organisation and how different modules work together...",
        keywords: "service modules overview core authentication module identity verification module (verifyyouridentity) attribute storage module (mysafe) consent management module module integration patterns basic authentication pattern verified attributes pattern identity verification pattern module responsibilities what each module handles integration considerations modular integration benefits module dependencies development approach modular development strategy module testing approach next steps",
        sections: [{"heading":"","id":"","content":"scotaccount is built using a modular architecture that separates concerns and enables flexible integration patterns. this page explains the service organisation and how different modules work together."},{"heading":"Service Modules Overview","id":"service-modules-overview","content":"scotaccount consists of several interconnected modules, each with specific responsibilities:"},{"heading":"Core Authentication Module","id":"core-authentication-module","content":"- primary responsibility: user authentication and session management\n- key features: openid connect authentication, jwt token issuance, session handling\n- integration point: all relying parties connect to this module for basic authentication"},{"heading":"Identity Verification Module (VerifyYourIdentity)","id":"identity-verification-module-verifyyouridentity","content":"- primary responsibility: gpg45 medium assurance identity verification\n- key features: document scanning, biometric verification, pep/sanctions checks\n- integration point: invoked when verified identity attributes are required"},{"heading":"Attribute Storage Module (mySafe)","id":"attribute-storage-module-mysafe","content":"- primary responsibility: secure storage and management of verified user data\n- key features: encrypted data storage, consent management, attribute retrieval\n- integration point: provides verified attributes to relying parties"},{"heading":"Consent Management Module","id":"consent-management-module","content":"- primary responsibility: user consent tracking and management\n- key features: granular consent controls, audit trails, user self-service\n- integration point: embedded in authentication flows requiring data sharing"},{"heading":"Module Integration Patterns","id":"module-integration-patterns","content":""},{"heading":"Basic Authentication Pattern","id":"basic-authentication-pattern","content":""},{"heading":"Verified Attributes Pattern","id":"verified-attributes-pattern","content":""},{"heading":"Identity Verification Pattern","id":"identity-verification-pattern","content":""},{"heading":"Module Responsibilities","id":"module-responsibilities","content":""},{"heading":"What Each Module Handles","id":"what-each-module-handles","content":"authentication module:\n\n- user registration and login\n- openid connect protocol implementation\n- jwt token generation and validation\n- session lifecycle management\n- basic user profile data\n\nidentity verification module:\n\n- document capture and verification\n- biometric identity matching\n- external service integration (experian, etc.)\n- verification workflow management\n- cross-device verification support\n\nattribute storage module:\n\n- encrypted storage of verified data\n- consent tracking and enforcement\n- data retrieval for authorised requests\n- audit logging and compliance\n- data retention and deletion\n\nconsent management module:\n\n- user consent collection\n- granular permission management\n- consent withdrawal handling\n- audit trail maintenance\n- user preference management"},{"heading":"Integration Considerations","id":"integration-considerations","content":""},{"heading":"Modular Integration Benefits","id":"modular-integration-benefits","content":"flexible implementation:\n\n- integrate only the modules you need\n- start with basic authentication, add verification later\n- independent module updates and maintenance\n\nscalable architecture:\n\n- modules can scale independently\n- load balancing per module\n- fault isolation between modules\n\nsecurity by design:\n\n- module-level security boundaries\n- least privilege access patterns\n- independent security auditing"},{"heading":"Module Dependencies","id":"module-dependencies","content":"core dependencies:\n\n- authentication module: required for all integrations\n- consent management: required when requesting verified attributes\n- identity verification: optional, based on service requirements\n- attribute storage: required for verified attribute access\n\noptional dependencies:\n\n- address verification services\n- email verification services\n- additional external verification providers"},{"heading":"Development Approach","id":"development-approach","content":""},{"heading":"Modular Development Strategy","id":"modular-development-strategy","content":"1. start with authentication module\n\n   - implement basic openid connect integration\n   - establish user session management\n   - test authentication flows\n\n2. add consent management\n\n   - implement consent collection\n   - add granular permission controls\n   - test consent workflows\n\n3. integrate verification module\n\n   - add identity verification flows\n   - implement cross-device support\n   - test verification processes\n\n4. enable attribute storage\n   - access verified user data\n   - implement secure data handling\n   - test attribute retrieval"},{"heading":"Module Testing Approach","id":"module-testing-approach","content":"unit testing:\n\n- test each module independently\n- mock external module dependencies\n- validate module interfaces\n\nintegration testing:\n\n- test module communication\n- validate data flow between modules\n- test error handling across modules\n\nend-to-end testing:\n\n- test complete user journeys\n- validate cross-module functionality\n- test module fault tolerance"},{"heading":"Next Steps","id":"next-steps","content":"need implementation guidance? start with the getting started guide to implement the authentication module first.\n\nplanning your architecture? review the architecture overview to understand how modules fit together.\n\nready for detailed implementation? see the complete implementation guide for comprehensive technical details."}]
      }
      
    ];
    this.searchData = pages;
  }

  setupFuse() {
    this.fuse = new window.Fuse(this.searchData, {
      keys: [
        { name: "title", weight: 2 },     // Title matches are more important
        { name: "keywords", weight: 1.5 }, // Keywords are fairly important
        { name: "content", weight: 1 },    // Full content search
        { name: "summary", weight: 0.8 }   // Summary is less important
      ],
      threshold: 0.4,           // Balance between precision and recall
      minMatchCharLength: 2,    // Minimum 2 characters
      includeScore: true,
      ignoreLocation: true,     // Search anywhere in content
      findAllMatches: true,     // Find all matches in content
      shouldSort: true          // Sort results by score
    });
  }

  setupSearchInterface() {
    // Get search input from header
    this.searchInput = document.getElementById("search-input");

    // Create search results container
    if (!document.getElementById("search-results")) {
      const resultsContainer = document.createElement("div");
      resultsContainer.id = "search-results";
      resultsContainer.className = "search-results";
      resultsContainer.style.display = "none";

      // Insert after search form
      const searchForm = document.querySelector(".sg-header__search-form");
      if (searchForm) {
        searchForm.parentNode.insertBefore(
          resultsContainer,
          searchForm.nextSibling
        );
      }
    }
    this.searchResults = document.getElementById("search-results");
  }

  bindEvents() {
    if (!this.searchInput) return;

    // Search on input
    this.searchInput.addEventListener("input", (e) => {
      const query = e.target.value.trim();
      if (query.length >= 2) {
        this.performSearch(query);
      } else {
        this.hideResults();
      }
    });

    // Handle search form submission
    const searchForm = document.querySelector(".sg-header__search-form");
    if (searchForm) {
      searchForm.addEventListener("submit", (e) => {
        e.preventDefault();
        const query = this.searchInput.value.trim();
        if (query.length >= 2) {
          this.performSearch(query);
        }
      });
    }

    // Hide results when clicking outside
    document.addEventListener("click", (e) => {
      if (
        !e.target.closest(".sg-header__search") &&
        !e.target.closest(".search-results")
      ) {
        this.hideResults();
      }
    });

    // Keyboard navigation
    this.searchInput.addEventListener("keydown", (e) => {
      if (e.key === "Escape") {
        this.hideResults();
        this.searchInput.blur();
      }
    });
  }

  performSearch(query, renderToPage = false) {
    if (!this.fuse) return;
    
    const results = this.fuse.search(query);
    const items = results.map((r) => r.item);
    
    if (renderToPage && document.getElementById("search-results-page")) {
      this.displayResultsPage(items, query);
    } else {
      this.displayResults(items, query);
    }
  }

  findBestSection(result, query) {
    if (!result.sections || result.sections.length === 0) {
      return null;
    }
    
    const queryLower = query.toLowerCase();
    let bestSection = null;
    let bestScore = -1;
    
    // Find the section with the best match
    result.sections.forEach(section => {
      const sectionContent = section.content.toLowerCase();
      const headingContent = section.heading.toLowerCase();
      
      // Higher score if query matches in heading
      if (headingContent.includes(queryLower)) {
        const score = 10;
        if (score > bestScore) {
          bestScore = score;
          bestSection = section;
        }
      }
      // Lower score if query matches in content
      else if (sectionContent.includes(queryLower)) {
        const score = 5;
        if (score > bestScore) {
          bestScore = score;
          bestSection = section;
        }
      }
    });
    
    return bestSection;
  }

  displayResults(results, query) {
    if (!this.searchResults) return;

    if (results.length === 0) {
      this.searchResults.innerHTML = `
        <div class="search-results__container">
          <div class="search-results__empty">
            <p>No results found for "${query}"</p>
            <p class="search-results__suggestion">Try searching for: authentication, token, OIDC, setup, or architecture</p>
          </div>
        </div>
      `;
    } else {
      const resultsHTML = results
        .map(
          (result) => {
            // Find the best matching section for deep linking
            const bestSection = this.findBestSection(result, query);
            const targetUrl = bestSection ? 
              `${result.url}#${bestSection.id}` : 
              result.url;
            const sectionInfo = bestSection ? 
              ` <span class="search-results__section">→ ${bestSection.heading}</span>` : 
              '';
            
            return `
        <div class="search-results__item">
          <a href="${targetUrl}" class="search-results__link">
            <h3 class="search-results__title">${result.title}${sectionInfo}</h3>
            <p class="search-results__summary">${this.getSearchSummary(
              result,
              query,
              bestSection
            )}</p>
          </a>
        </div>
      `;
          }
        )
        .join("");

      this.searchResults.innerHTML = `
        <div class="search-results__container">
          <div class="search-results__header">
            <p class="search-results__count">${results.length} result${
        results.length !== 1 ? "s" : ""
      } for "${query}"</p>
          </div>
          ${resultsHTML}
        </div>
      `;
    }

    this.searchResults.style.display = "block";
  }

  displayResultsPage(results, query) {
    const container = document.getElementById("search-results-page");
    if (!container) return;
    if (results.length === 0) {
      container.innerHTML = `
        <div class="search-results__container">
          <div class="search-results__empty">
            <p>No results found for "${query}"</p>
            <p class="search-results__suggestion">Try searching for: authentication, token, OIDC, setup, or architecture</p>
          </div>
        </div>
      `;
    } else {
      const resultsHTML = results
        .map(
          (result) => {
            // Find the best matching section for deep linking
            const bestSection = this.findBestSection(result, query);
            const targetUrl = bestSection ? 
              `${result.url}#${bestSection.id}` : 
              result.url;
            const sectionInfo = bestSection ? 
              ` <span class="search-results__section">→ ${bestSection.heading}</span>` : 
              '';
            
            return `
        <div class="search-results__item">
          <a href="${targetUrl}" class="search-results__link">
            <h3 class="search-results__title">${result.title}${sectionInfo}</h3>
            <p class="search-results__summary">${this.getSearchSummary(
              result,
              query,
              bestSection
            )}</p>
          </a>
        </div>
      `;
          }
        )
        .join("");
      container.innerHTML = `
        <div class="search-results__container">
          <div class="search-results__header">
            <p class="search-results__count">${results.length} result${
        results.length !== 1 ? "s" : ""
      } for "${query}"</p>
          </div>
          ${resultsHTML}
        </div>
      `;
    }
  }

  getSearchSummary(result, query, bestSection) {
    // Use section content if available, otherwise use page content
    const searchContent = bestSection ? bestSection.content : result.content;
    const content = searchContent.toLowerCase();
    const queryLower = query.toLowerCase();
    const index = content.indexOf(queryLower);

    if (index === -1) return searchContent.substring(0, 120) + "...";

    const start = Math.max(0, index - 40);
    const end = Math.min(content.length, index + query.length + 40);
    let snippet = searchContent.substring(start, end);

    if (start > 0) snippet = "..." + snippet;
    if (end < content.length) snippet = snippet + "...";

    return snippet;
  }

  hideResults() {
    if (this.searchResults) {
      this.searchResults.style.display = "none";
    }
  }
}

// Initialize search when DOM is loaded
if (typeof window !== "undefined") {
  document.addEventListener("DOMContentLoaded", () => {
    if (window.Fuse) {
      window.__docSearchInstance = new DocumentationSearch();
    } else {
      // Load Fuse.js from CDN if not already loaded
      const script = document.createElement("script");
      script.src =
        "https://cdn.jsdelivr.net/npm/fuse.js@6.6.2/dist/fuse.min.js";
      script.onload = () => {
        window.__docSearchInstance = new DocumentationSearch();
      };
      document.body.appendChild(script);
    }
  });
}